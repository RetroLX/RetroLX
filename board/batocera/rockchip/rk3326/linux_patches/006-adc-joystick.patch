--- /dev/null	2021-05-11 16:39:45.136666607 +0200
+++ b/drivers/input/joystick/adc-gpio.c	2021-05-13 18:42:21.903417858 +0200
@@ -0,0 +1,157 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/property.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/gpio_keys.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/consumer.h>
+#include <linux/iio/driver.h>
+
+struct adc_joystick_polled_axis {
+	u32 code;
+	s32 range[2];
+	s32 fuzz;
+	s32 flat;
+	int is_analog;
+	struct gpio_desc *gpiod;
+	int prev_val;
+};
+
+struct adc_joystick_polled {
+	struct input_dev *input;
+	struct adc_joystick_polled_axis *axes;
+	struct iio_channel *chans;
+	int num_chans;
+};
+
+static int adc_joystick_set_axes(struct device *dev, struct adc_joystick_polled *joy)
+{
+	struct adc_joystick_polled_axis *axes;
+	struct fwnode_handle *child;
+	int num_axes, err, i;
+
+	num_axes = device_get_child_node_count(dev);
+	joy->num_chans = num_axes;
+
+	axes = devm_kmalloc_array(dev, num_axes, sizeof(*axes), GFP_KERNEL);
+
+	device_for_each_child_node(dev, child) {
+		fwnode_property_read_u32(child, "reg", &i);
+
+		fwnode_property_read_u32(child, "linux,code", &axes[i].code);
+
+		if (fwnode_property_present(child, "analog"))
+		{
+			axes[i].is_analog = 1;
+
+			fwnode_property_read_u32_array(child, "abs-range", axes[i].range, 2);
+			fwnode_property_read_u32(child, "abs-fuzz", &axes[i].fuzz);
+			fwnode_property_read_u32(child, "abs-flat", &axes[i].flat);
+			input_set_abs_params(joy->input, axes[i].code,
+					axes[i].range[0], axes[i].range[1],
+					axes[i].fuzz, axes[i].flat);
+			input_set_capability(joy->input, EV_ABS, axes[i].code);
+		}
+		else
+		{
+			axes[i].is_analog = 0;
+			axes[i].gpiod = devm_fwnode_gpiod_get(dev, child, NULL, GPIOD_IN, "btn");
+			input_set_capability(joy->input, EV_KEY, axes[i].code);
+		}
+
+	}
+
+	joy->axes = axes;
+	return 0;
+}
+
+static void adc_joystick_polled_poll(struct input_dev *input)
+{
+	struct adc_joystick_polled *bdev = input_get_drvdata(input);
+	int ret;
+	int i;
+
+	int raw;
+
+	for (i = 0; i < bdev->num_chans; i++) {
+		if (bdev->axes[i].is_analog == 1)
+		{
+			iio_read_channel_raw(&bdev->chans[i], &raw);
+			input_event(input, EV_ABS, bdev->axes[i].code, raw);
+		}
+		else
+		{
+			raw = gpiod_get_value_cansleep(bdev->axes[i].gpiod);
+			if (raw != bdev->axes[i].prev_val)
+			{
+				input_event(input, EV_KEY, bdev->axes[i].code, raw);
+				bdev->axes[i].prev_val = raw;
+			}
+		}
+	}
+
+	input_sync(input);
+}
+
+static int adc_joystick_polled_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct adc_joystick_polled *joy;
+	struct input_dev *input;
+	const struct gpio_keys_platform_data *pdata = dev_get_platdata(dev);
+	int err;
+
+	joy = devm_kzalloc(dev, sizeof(*joy), GFP_KERNEL);
+	if (!joy)
+		return -ENOMEM;
+
+	joy->chans = devm_iio_channel_get_all(dev);
+	if (IS_ERR(joy->chans)) {
+		err = PTR_ERR(joy->chans);
+		if (err != -EPROBE_DEFER)
+			dev_err(dev, "Unable to get IIO channels");
+		return err;
+	}
+
+	input = devm_input_allocate_device(dev);
+	if (!input)
+		return -ENOMEM;
+
+	joy->input = input;
+
+	input->name = pdev->name;
+	input->id.bustype = BUS_HOST;
+
+	input_setup_polling(input, adc_joystick_polled_poll);
+	input_set_poll_interval(input, 10);
+	
+	adc_joystick_set_axes(dev, joy);	
+
+	input_set_drvdata(input, joy);
+
+	input_register_device(input);
+
+	printk("adc-joystick-polled: Bound to device correctly!");
+	return 0;
+}
+
+static const struct of_device_id adc_joystick_polled_of_match[] = {
+	{ .compatible = "gpio-keys-adc", },
+	{ }
+};
+
+static struct platform_driver adc_joystick_polled_driver = {
+	.driver = {
+		.name = "adc-joystick-polled",
+		.of_match_table = adc_joystick_polled_of_match,
+	},
+	.probe = adc_joystick_polled_probe,
+};
+module_platform_driver(adc_joystick_polled_driver);
+
+
--- a/drivers/input/joystick/Kconfig	2021-05-13 18:43:14.986749259 +0200
+++ b/drivers/input/joystick/Kconfig	2021-05-13 18:43:28.733415427 +0200
@@ -15,6 +15,9 @@
 
 if INPUT_JOYSTICK
 
+config JOYSTICK_ADC_GPIO
+	tristate "ADC Analog + GPIO keys. Polled."
+
 config JOYSTICK_ANALOG
 	tristate "Classic PC analog joysticks and gamepads"
 	select GAMEPORT
@@ -382,4 +385,11 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called fsia6b.
 
+config JOYSTICK_N64
+	bool "N64 controller"
+	depends on MACH_NINTENDO64
+	help
+	  Say Y here if you want enable support for the four
+	  built-in controller ports on the Nintendo 64 console.
+
 endif
--- a/drivers/input/joystick/Makefile	2021-05-13 18:43:17.886749152 +0200
+++ b/drivers/input/joystick/Makefile	2021-05-13 18:44:01.110080921 +0200
@@ -24,6 +24,7 @@
 obj-$(CONFIG_JOYSTICK_JOYDUMP)		+= joydump.o
 obj-$(CONFIG_JOYSTICK_MAGELLAN)		+= magellan.o
 obj-$(CONFIG_JOYSTICK_MAPLE)		+= maplecontrol.o
+obj-$(CONFIG_JOYSTICK_N64)		+= n64joy.o
 obj-$(CONFIG_JOYSTICK_PSXPAD_SPI)	+= psxpad-spi.o
 obj-$(CONFIG_JOYSTICK_PXRC)		+= pxrc.o
 obj-$(CONFIG_JOYSTICK_SIDEWINDER)	+= sidewinder.o
@@ -37,4 +38,4 @@
 obj-$(CONFIG_JOYSTICK_WALKERA0701)	+= walkera0701.o
 obj-$(CONFIG_JOYSTICK_XPAD)		+= xpad.o
 obj-$(CONFIG_JOYSTICK_ZHENHUA)		+= zhenhua.o
-
+obj-$(CONFIG_JOYSTICK_ADC_GPIO)		+= adc-gpio.o
