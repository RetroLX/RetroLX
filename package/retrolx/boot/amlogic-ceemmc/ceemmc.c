/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2017 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void __fastcall __noreturn start(void (*a1)(void), __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, char a10);
__int64 (**sub_4014F0())(void);
__int64 *sub_401538();
unsigned __int64 __fastcall sub_4015A4(unsigned __int64 result);
__int64 sub_4015DC();
bool __fastcall stat(const char *a1);
bool __fastcall sub_40166C(const char *a1);
signed __int64 __fastcall sub_40169C(const char *a1);
__int64 __fastcall sub_401868(char *a1, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, long double a9, long double a10, long double a11, long double a12, long double a13, long double a14, long double a15, long double a16, char a17);
__int64 sub_401980();
signed __int64 __fastcall sub_401B88(const void *a1, const char *a2, int a3, int a4);
signed __int64 __fastcall do_backup(void **a1, const char *a2, int a3, int a4);
signed __int64 __fastcall sub_401DE0(unsigned int *a1, const char *a2);
__int64 __fastcall sub_401E48(__int64 a1);
__int64 __fastcall sub_401EC0(_DWORD *a1, int a2);
const char *__fastcall sub_401F4C(int a1);
signed __int64 __fastcall sub_401FAC(__int64 a1, const char *a2, unsigned int *a3);
signed __int64 __fastcall sub_4020D0(const char *a1, __int64 a2, __int64 a3);
signed __int64 __fastcall sub_402468(__int64 a1, __int64 a2);
signed __int64 __fastcall sub_402520(int *a1, const char *a2);
signed __int64 __fastcall sub_40283C(void **a1, const char *a2);
signed __int64 __fastcall sub_4029B4(const void *a1, const char *a2);
signed __int64 __fastcall run_command(const char *a1, void *a2, FILE *a3);
signed __int64 __fastcall sub_402DB0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
signed __int64 __fastcall sub_402EC0(__int64 a1, const char *a2);
signed __int64 format_vfat_partition();
signed __int64 __fastcall sub_403044(__int64 a1, const char *a2);
signed __int64 __fastcall sub_4031D4(const char *a1);
signed __int64 __fastcall sub_40329C(const char *a1);
signed __int64 __fastcall sub_40337C(__int64 a1, __int64 a2, void *a3);
signed __int64 __fastcall sub_403418(__int64 a1, const char *a2, const char *a3);
signed __int64 __fastcall sub_403624(const char *a1);
signed __int64 __fastcall sub_4036D8(const char *a1);
signed __int64 sub_403788();
signed __int64 __fastcall sub_403888(__int64 a1, const char *a2);
signed __int64 __fastcall sub_403968(__int64 a1, char a2);
signed __int64 __fastcall sub_403B48(__int64 a1, __int64 a2);
signed __int64 sub_403C6C();
__int64 __fastcall sub_403CE0(const char *a1);
signed __int64 __fastcall sub_403D38(const char *a1, __int64 *a2);
__int64 sub_403E18();
__int64 __fastcall sub_403F18(__int64 a1, const char *a2);
signed __int64 __fastcall sub_403F5C(__int64 a1, const char *a2, __int64 *a3);
signed __int64 __fastcall sub_403FDC(__int64 a1, const char *a2, _QWORD *a3);
signed __int64 __fastcall sub_404068(__int64 a1, const char *a2, __int64 *a3);
signed __int64 __fastcall sub_404134(const char *a1, int a2);
signed __int64 __fastcall sub_4043E8(__int64 a1, const char *a2);
char *__fastcall sub_404628(__int64 a1, char *a2);
signed __int64 __fastcall sub_404804(const void *a1, int *a2);
signed __int64 __fastcall sub_404B1C(_QWORD *a1, char *a2);
signed __int64 __fastcall create_new_partition_table(int a1, _QWORD *a2, int *a3, _QWORD *a4, __int64 *a5);

signed __int64 __fastcall sub_405CC8(__int64 a1, int a2);
signed __int64 __fastcall sub_4063E4(_QWORD *a1, unsigned int a2);
signed __int64 __fastcall sub_406D8C(__int64 a1);
signed __int64 sub_4071D8();

__int64 __fastcall sub_408164(); // weak
signed __int64 __fastcall sub_409320(__int64 a1, int a2, __int64 a3, _QWORD *a4, int a5, int a6);
signed __int64 __fastcall sub_409494(__int64 a1, signed __int64 *a2, __int64 a3, unsigned __int64 a4, int a5, __int64 (__fastcall *a6)(__int64, signed __int64));
signed __int64 __fastcall sub_40976C(__int64 a1, signed __int64 *a2, __int64 a3, unsigned __int64 a4);
signed __int64 __fastcall sub_4097A8(__int64 a1, int a2, _BYTE *a3, _QWORD *a4);
unsigned int __fastcall sub_409920(unsigned int *a1);
unsigned __int64 __fastcall sub_40992C(unsigned __int64 *a1);
signed __int64 __fastcall sub_409938(__int64 a1);
__int64 __fastcall sub_4099FC(__int64 a1, int a2, unsigned int *a3);
char *__fastcall sub_409A64(unsigned int *a1, unsigned int a2, signed int *a3);
__int64 __fastcall sub_409C08(__int64 a1);
const char *__fastcall sub_409C4C(unsigned int *a1, int a2, signed int *a3);
__int64 __fastcall sub_409CF8(unsigned int *a1, unsigned int a2, const void *a3, int a4);
signed __int64 __fastcall sub_409E2C(__int64 a1, int a2);
signed __int64 __fastcall sub_409E64(__int64 a1, int a2);
__int64 __fastcall sub_409E9C(__int64 a1, int a2, const void *a3, int a4, unsigned int *a5, int *a6);
__int64 __fastcall sub_40A00C(__int64 a1, __int64 a2, const char *a3);
__int64 __fastcall sub_40A04C(__int64 a1, int a2, const void *a3, int a4, unsigned int *a5);
__int64 __fastcall sub_40A0B8(__int64 a1, int a2, char **a3, unsigned int *a4);
__int64 __fastcall sub_40A174(__int64 a1, int a2, const char *a3, unsigned int *a4);
__int64 __fastcall sub_40A1B4(__int64 a1, int a2);
__int64 __fastcall sub_40A2B4(__int64 a1, const void *a2, int a3);
__int64 __fastcall sub_40A408(unsigned int *a1, const char *a2);
signed __int64 __fastcall sub_40A5F0(unsigned int *a1, int a2, int a3, _DWORD *a4);
__int64 __fastcall sub_40A6AC(unsigned int *a1, int a2);
signed __int64 __fastcall sub_40A864(const void *a1, int a2, const char *a3);
__int64 __fastcall sub_40AAE8(__int64 a1, int a2, const char *a3);
unsigned int __fastcall sub_40ACD4(unsigned int a1);
unsigned __int64 __fastcall sub_40ACDC(unsigned __int64 a1);
unsigned int __fastcall sub_40ACE4(unsigned int *a1);
bool __fastcall sub_40ACF0(__int64 a1);
signed __int64 __fastcall sub_40AD70(unsigned int *a1);
__int64 __fastcall sub_40ADE4(unsigned int *a1, _DWORD *a2, int a3, signed int a4);
signed __int64 __fastcall sub_40AEB8(__int64 a1);
__int64 __fastcall sub_40AF54(__int64 a1, __int64 a2, int a3, int a4);
__int64 __fastcall sub_40AFC8(__int64 a1, __int64 a2, int a3, int a4);
__int64 __fastcall sub_40B030(__int64 a1, int a2, const char *a3, unsigned int a4, _QWORD *a5);
signed __int64 __fastcall sub_40B34C(unsigned int *a1, unsigned int a2, const char *a3, unsigned int a4, _QWORD *a5);
__int64 __fastcall sub_40B734(unsigned int *a1, signed int a2);
__int64 __fastcall sub_40B95C(unsigned int *a1);
unsigned int __fastcall sub_40B9D4(unsigned int *a1);
signed __int64 __fastcall sub_40B9E0(unsigned int *a1);
signed __int64 __fastcall sub_40BA64(unsigned int a1);
signed __int64 __fastcall sub_40BA98(unsigned int *a1);
unsigned __int64 __fastcall sub_40BBD0(__int64 a1, int a2);
__int64 __fastcall sub_40BC58(__int64 a1, int a2, unsigned int *a3);
signed __int64 __fastcall sub_40BDA4(__int64 a1, int a2);
signed __int64 __fastcall sub_40BDE4(__int64 a1, int a2);
__int64 __fastcall sub_40BE24(__int64 a1, int a2, int *a3);
char *__fastcall sub_40BF7C(char *a1, int a2, const char *a3);
__int64 __fastcall sub_40BFEC(unsigned int *a1, void *a2, unsigned int a3);
signed __int64 __fastcall sub_40C050(__int64 a1, int a2, const void *a3, int a4, unsigned int a5, const void *a6, int a7);
__int64 __fastcall sub_40C18C(__int64 a1, unsigned int a2);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_40998C; // weak
_UNKNOWN unk_40CF50; // weak
_UNKNOWN unk_40FA89; // weak
int dword_4221E4 = 4294967295; // weak
char *off_4221F0 = "env"; // weak
__int64 stdout; // weak
char byte_422220; // weak
int dword_422228; // weak
int dword_42222C; // weak
__int64 qword_422230; // weak
__int64 qword_422238; // weak

//----- (00000000004015A4) ----------------------------------------------------
unsigned __int64 __fastcall sub_4015A4(unsigned __int64 result)
{
  if ( (unsigned int)result > 2 )
    result = 0x100000000uLL >> __clz(result - 1);
  else
    result = (unsigned int)result;
  return result;
}

//----- (00000000004015DC) ----------------------------------------------------
__int64 sub_4015DC()
{
  unsigned __int8 v1; // [xsp+1Fh] [xbp+1Fh]

  v1 = getchar();
  if ( v1 == 10 )
    return 0LL;
  while ( (unsigned int)getchar() != 10 )
    ;
  return (unsigned __int8)tolower(v1);
}

//----- (000000000040166C) ----------------------------------------------------
bool __fastcall sub_40166C(const char *a1)
{
  char v2; // [xsp+20h] [xbp+20h]

  return (unsigned int)__xstat(0, a1, (struct stat *)&v2) == 0;
}

//----- (000000000040169C) ----------------------------------------------------
signed __int64 __fastcall sub_40169C(const char *a1)
{
  signed __int64 result; // x0
  const char *v2; // [xsp+18h] [xbp+18h]
  FILE *v3; // [xsp+28h] [xbp+28h]

  v2 = a1;
  if ( !stat("/storage/.config") )
    return 0xFFFFFFFFLL;
  v3 = fopen("/storage/.config/boot.hint", "w");
  if ( !v3 )
    return 0xFFFFFFFFLL;
  if ( (signed int)fputs(v2, v3) >= 0 )
  {
    if ( (signed int)fputc(10, v3) >= 0 )
    {
      fclose(v3);
      result = 0LL;
    }
    else
    {
      fclose(v3);
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    fclose(v3);
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (0000000000401868) ----------------------------------------------------
__int64 __fastcall sub_401868(char *a1, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, long double a9, long double a10, long double a11, long double a12, long double a13, long double a14, long double a15, long double a16, char a17)
{
  long double vars0; // ST50_16
  long double vars10; // ST60_16
  long double vars20; // ST70_16
  long double vars30; // ST80_16
  long double vars40; // ST90_16
  long double vars50; // STA0_16
  long double vars60; // STB0_16
  long double vars70; // STC0_16
  signed int v25; // w1
  char *v26; // x0
  __int64 v27; // x3
  __int64 result; // x0
  unsigned __int64 v29; // [xsp+10h] [xbp+10h]
  char *v30; // [xsp+18h] [xbp+18h]
  char *v31; // [xsp+28h] [xbp+28h]
  signed int v32; // [xsp+40h] [xbp+40h]
  int i; // [xsp+4Ch] [xbp+4Ch]
  __int64 vars80; // [xsp+D0h] [xbp+D0h]
  __int64 vars88; // [xsp+D8h] [xbp+D8h]
  __int64 vars90; // [xsp+E0h] [xbp+E0h]
  __int64 vars98; // [xsp+E8h] [xbp+E8h]
  __int64 varsA0; // [xsp+F0h] [xbp+F0h]
  __int64 varsA8; // [xsp+F8h] [xbp+F8h]

  vars80 = a3;
  vars88 = a4;
  vars90 = a5;
  vars98 = a6;
  varsA0 = a7;
  varsA8 = a8;
  vars0 = a9;
  vars10 = a10;
  vars20 = a11;
  vars30 = a12;
  vars40 = a13;
  vars50 = a14;
  vars60 = a15;
  vars70 = a16;
  v30 = a1;
  v29 = a2;
  v31 = &a17;
  v32 = -48;
  for ( i = 0; ; ++i )
  {
    result = i;
    if ( v29 <= i )
      break;
    v25 = v32;
    v26 = v31;
    if ( v32 < 0 )
    {
      v32 += 8;
      if ( v25 + 8 <= 0 )
        v26 = &a17 + v25;
      else
        v31 = (char *)((unsigned __int64)(v31 + 11) & 0xFFFFFFFFFFFFFFF8LL);
    }
    else
    {
      v31 = (char *)((unsigned __int64)(v31 + 11) & 0xFFFFFFFFFFFFFFF8LL);
    }
    v27 = *(_DWORD *)v26 & 0xFF;
    sprintf(v30, "%s%c");
  }
  return result;
}

//----- (0000000000401980) ----------------------------------------------------
__int64 sub_401980()
{
  long double v0; // q0
  long double v1; // q1
  long double v2; // q2
  long double v3; // q3
  long double v4; // q4
  long double v5; // q5
  long double v6; // q6
  long double v7; // q7
  __int64 v8; // x5
  __int64 v9; // x6
  __int64 v10; // x7
  long double v11; // q0
  long double v12; // q1
  long double v13; // q2
  long double v14; // q3
  long double v15; // q4
  long double v16; // q5
  long double v17; // q6
  long double v18; // q7
  long double v19; // q0
  long double v20; // q1
  long double v21; // q2
  long double v22; // q3
  long double v23; // q4
  long double v24; // q5
  long double v25; // q6
  long double v26; // q7
  char v28; // [xsp+0h] [xbp-50h]
  time_t v29; // [xsp+60h] [xbp+10h]
  char v30; // [xsp+68h] [xbp+18h]
  char v31; // [xsp+268h] [xbp+218h]
  char v32; // [xsp+368h] [xbp+318h]
  struct tm *v33; // [xsp+468h] [xbp+418h]
  FILE *v34; // [xsp+470h] [xbp+420h]
  unsigned int v35; // [xsp+47Ch] [xbp+42Ch]

  v34 = 0LL;
  memset(&v32, 0, 0x100uLL);
  memset(&v31, 0, 0x100uLL);
  memset(&v30, 0, 0x200uLL);
  v35 = 0;
  memset(&v32, 0, 0x100uLL);
  sub_401868(&v32, 0xFuLL, 47LL, 101LL, 116LL, 99LL, 47LL, 111LL, v0, v1, v2, v3, v4, v5, v6, v7, 115);
  time(&v29);
  v33 = localtime(&v29);
  v35 = v33->tm_sec / 2;
  strcat(&v30, &v32);
  v34 = fopen(&v30, "r");
  if ( v34 )
  {
    memset(&v32, 0, 0x100uLL);
    sub_401868(&v32, 3uLL, 73LL, 68LL, 61LL, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v28);
    while ( fgets(&v31, 256, v34) )
    {
      if ( strstr(&v31, &v32) )
      {
        memset(&v32, 0, 0x100uLL);
        sub_401868(&v32, 8uLL, 99LL, 111LL, 114LL, 101LL, 101LL, 108LL, v19, v20, v21, v22, v23, v24, v25, v26, 101);
        if ( strstr(&v31, &v32) )
        {
          v35 = -1;
          break;
        }
      }
    }
    fclose(v34);
  }
  return v35;
}

//----- (0000000000401B88) ----------------------------------------------------
signed __int64 __fastcall sub_401B88(const void *a1, const char *a2, int a3, int a4)
{
  signed __int64 result; // x0
  int v5; // [xsp+18h] [xbp+18h]
  int v6; // [xsp+1Ch] [xbp+1Ch]
  const void *v7; // [xsp+28h] [xbp+28h]
  FILE *v8; // [xsp+38h] [xbp+38h]

  v7 = a1;
  v6 = a3;
  v5 = a4;
  if ( a1 )
  {
    v8 = fopen(a2, "wb+");
    if ( v8 )
    {
      if ( (unsigned int)fseek(v8, v6, 0) )
      {
        puts("Error seek file!");
        fclose(v8);
        result = 0xFFFFFFFFLL;
      }
      else if ( fwrite(v7, v5, 1uLL, v8) == 1 )
      {
        fflush(v8);
        fclose(v8);
        result = 0LL;
      }
      else
      {
        puts("Error writing file!");
        fclose(v8);
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      printf("Error opening file for writing '%s'!\n");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    puts("backup is NULL!");
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (0000000000401C88) ----------------------------------------------------
signed __int64 __fastcall do_backup(void **a1, const char *a2, int a3, int a4)
{
  signed __int64 result; // x0
  int v5; // [xsp+18h] [xbp+18h]
  int v6; // [xsp+1Ch] [xbp+1Ch]
  const char *v7; // [xsp+20h] [xbp+20h]
  void **v8; // [xsp+28h] [xbp+28h]
  FILE *v9; // [xsp+38h] [xbp+38h]
  FILE *v10; // [xsp+38h] [xbp+38h]

  v8 = a1;
  v7 = a2;
  v6 = a3;
  v5 = a4;
  if ( a1 )
  {
    *a1 = calloc(1uLL, a4);
    if ( *v8 )
    {
      v10 = fopen(v7, "rb+");
      if ( v10 )
      {
        if ( (unsigned int)fseek(v10, v6, 0) )
        {
          puts("Error seek file!");
          free(*v8);
          fclose(v10);
          result = 0xFFFFFFFFLL;
        }
        else if ( fread(*v8, v5, 1uLL, v10) == 1 )
        {
          fclose(v10);
          result = 0LL;
        }
        else
        {
          puts("Error reading file!");
          free(*v8);
          fclose(v10);
          result = 0xFFFFFFFFLL;
        }
      }
      else
      {
        printf("Error opening file for reading '%s'!\n");
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      puts("malloc failed for backup!");
      fclose(v9);
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    puts("backup is NULL!");
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (0000000000401DE0) ----------------------------------------------------
signed __int64 __fastcall sub_401DE0(unsigned int *a1, const char *a2)
{
  unsigned int *v3; // [xsp+18h] [xbp+18h]
  signed int v4; // [xsp+2Ch] [xbp+2Ch]

  v3 = a1;
  v4 = sub_40A408(a1, a2);
  if ( v4 < 0 )
    return 0xFFFFFFFFLL;
  if ( (signed int)sub_40B734(v3, v4) >= 0 )
    return 0LL;
  return 0xFFFFFFFFLL;
}

//----- (0000000000401E48) ----------------------------------------------------
__int64 __fastcall sub_401E48(__int64 a1)
{
  unsigned int v1; // w0
  __int64 v3; // [xsp+18h] [xbp-18h]
  unsigned int v4; // [xsp+28h] [xbp-8h]
  unsigned int v5; // [xsp+2Ch] [xbp-4h]

  v5 = 0;
  v4 = 0;
  v3 = a1;
  while ( v5 < 0xFFFF )
  {
    v1 = v5++;
    v4 += *(_DWORD *)(v3 + 4LL * v1);
  }
  return v4;
}

//----- (0000000000401EC0) ----------------------------------------------------
__int64 __fastcall sub_401EC0(_DWORD *a1, int a2)
{
  _DWORD *v3; // [xsp+18h] [xbp-18h]
  unsigned int v4; // [xsp+24h] [xbp-Ch]
  signed int j; // [xsp+28h] [xbp-8h]
  int i; // [xsp+2Ch] [xbp-4h]

  v4 = 0;
  for ( i = 0; i < a2; ++i )
  {
    v3 = a1;
    for ( j = 10; j > 0; --j )
    {
      v4 += *v3;
      ++v3;
    }
  }
  return v4;
}

//----- (0000000000401F4C) ----------------------------------------------------
const char *__fastcall sub_401F4C(int a1)
{
  switch ( a1 )
  {
    case 2:
      return "cache";
    case 4:
      return "data";
    case 1:
      return "code";
  }
  return "unkn";
}

//----- (0000000000401FAC) ----------------------------------------------------
signed __int64 __fastcall sub_401FAC(__int64 a1, const char *a2, unsigned int *a3)
{
  unsigned int *v4; // [xsp+18h] [xbp+18h]
  const char *v5; // [xsp+20h] [xbp+20h]
  __int64 v6; // [xsp+28h] [xbp+28h]
  unsigned int i; // [xsp+4Ch] [xbp+4Ch]

  v6 = a1;
  v5 = a2;
  v4 = a3;
  for ( i = 0; ; ++i )
  {
    if ( i > 0x1F )
      return 0xFFFFFFFFLL;
    if ( dword_4221E4 >= 0 && ++dword_42222C >= dword_4221E4 )
    {
      putchar(10);
      fflush((FILE *)stdout);
      MEMORY[0] = 10;
    }
    if ( v6 + 40LL * i + 16 != -8 && !(unsigned int)strcmp(v5, (const char *)(v6 + 40LL * i + 16 + 8)) )
      break;
  }
  if ( v4 )
    *v4 = i;
  return 0LL;
}
// 4221E4: using guessed type int dword_4221E4;
// 422218: using guessed type __int64 stdout;
// 42222C: using guessed type int dword_42222C;

//----- (00000000004020D0) ----------------------------------------------------
signed __int64 __fastcall sub_4020D0(const char *a1, __int64 a2, __int64 a3)
{
  signed __int64 result; // x0
  __int64 v4; // x5
  __int64 v5; // x3
  __int64 v6; // x4
  __int64 v7; // [xsp+18h] [xbp+18h]
  __int64 v8; // [xsp+20h] [xbp+20h]
  const char *v9; // [xsp+28h] [xbp+28h]
  int v10; // [xsp+30h] [xbp+30h]
  int v11; // [xsp+34h] [xbp+34h]
  void *v12; // [xsp+38h] [xbp+38h]
  FILE *v13; // [xsp+40h] [xbp+40h]
  unsigned int i; // [xsp+4Ch] [xbp+4Ch]

  v9 = a1;
  v8 = a2;
  v7 = a3;
  if ( (signed int)sub_401FAC(a2, a1, (unsigned int *)&v11) >= 0 )
  {
    if ( (signed int)sub_401FAC(v7, v9, (unsigned int *)&v10) >= 0 )
    {
      if ( *(_QWORD *)(v8 + 40LL * v11 + 48) == *(_QWORD *)(v7 + 40LL * v10 + 48) )
      {
        result = 0LL;
      }
      else
      {
        v13 = fopen("/dev/mmcblk0", "rb+");
        if ( v13 )
        {
          v12 = calloc(1uLL, 0x200uLL);
          if ( v12 )
          {
            for ( i = 0; (unsigned __int64)i < *(_QWORD *)(v8 + 40LL * v11 + 40) >> 9; ++i )
            {
              if ( (unsigned int)fseek(v13, *(_QWORD *)(v8 + 40LL * v11 + 48) + ((unsigned __int64)i << 9), 0) )
              {
                puts("Error seek file!");
                free(v12);
                fclose(v13);
                return 0xFFFFFFFFLL;
              }
              if ( fread(v12, 0x200uLL, 1uLL, v13) != 1 )
              {
                puts("Error reading file!");
                free(v12);
                fclose(v13);
                return 0xFFFFFFFFLL;
              }
              if ( (unsigned int)fseek(v13, *(_QWORD *)(v7 + 40LL * v10 + 48) + ((unsigned __int64)i << 9), 0) )
              {
                puts("Error seek file!");
                free(v12);
                fclose(v13);
                return 0xFFFFFFFFLL;
              }
              if ( fwrite(v12, 0x200uLL, 1uLL, v13) != 1 )
              {
                puts("Error writing file!");
                free(v12);
                fclose(v13);
                return 0xFFFFFFFFLL;
              }
            }
            free(v12);
            fflush(v13);
            fclose(v13);
            v4 = *(_QWORD *)(v8 + 40LL * v11 + 48);
            v5 = *(_QWORD *)(v8 + 40LL * v11 + 40);
            v6 = *(_QWORD *)(v7 + 40LL * v10 + 48);
            printf("Moved '%s' from offset 0x%012llx, size 0x%012llx to offset 0x%012llx\n");
            result = 0LL;
          }
          else
          {
            printf("malloc failed for '%s' backup!\n");
            fclose(v13);
            result = 0xFFFFFFFFLL;
          }
        }
        else
        {
          printf("Error opening file for writing '%s'!\n");
          result = 0xFFFFFFFFLL;
        }
      }
    }
    else
    {
      printf("No partition '%s' found on new table!\n");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    printf("No partition '%s' found on old table!\n");
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (0000000000402468) ----------------------------------------------------
signed __int64 __fastcall sub_402468(__int64 a1, __int64 a2)
{
  char *v2; // x1
  __int64 v4; // [xsp+10h] [xbp+10h]
  __int64 v5; // [xsp+18h] [xbp+18h]
  unsigned int i; // [xsp+2Ch] [xbp+2Ch]

  v5 = a1;
  v4 = a2;
  putchar(10);
  for ( i = 0; i <= 4; ++i )
  {
    if ( !(unsigned int)sub_401FAC(v5, (&off_4221F0)[i], 0LL) && (signed int)sub_4020D0((&off_4221F0)[i], v5, v4) < 0 )
    {
      v2 = (&off_4221F0)[i];
      printf("Failed to move memory of partition %s\n");
      return 0xFFFFFFFFLL;
    }
  }
  return 0LL;
}
// 4221F0: using guessed type char *off_4221F0;

//----- (0000000000402520) ----------------------------------------------------
signed __int64 __fastcall sub_402520(int *a1, const char *a2)
{
  const char *v3; // [xsp+10h] [xbp+10h]
  __int64 v4; // [xsp+18h] [xbp+18h]
  unsigned __int64 v5; // [xsp+28h] [xbp+28h]
  __int64 v6; // [xsp+30h] [xbp+30h]
  unsigned int v7; // [xsp+3Ch] [xbp+3Ch]
  int v8; // [xsp+40h] [xbp+40h]
  unsigned int v9; // [xsp+44h] [xbp+44h]
  int v10; // [xsp+48h] [xbp+48h]
  int v11; // [xsp+4Ch] [xbp+4Ch]
  unsigned int v12; // [xsp+50h] [xbp+50h]
  int v13; // [xsp+54h] [xbp+54h]
  unsigned int i; // [xsp+58h] [xbp+58h]
  int v15; // [xsp+5Ch] [xbp+5Ch]
  int *v16; // [xsp+60h] [xbp+60h]
  int *v17; // [xsp+68h] [xbp+68h]

  v4 = (__int64)a1;
  v3 = a2;
  v17 = 0LL;
  v6 = 0x40000LL;
  v5 = 5242880LL;
  v16 = a1;
  v12 = 0;
  v15 = *a1;
  if ( (unsigned int)strcmp((const char *)a1 + 262128, "A~D") )
  {
    printf("Error dtb magic: %s!\n");
    return 0xFFFFFFFFLL;
  }
  if ( (unsigned __int16)v15 == 35615 )
  {
    v17 = (int *)calloc(1uLL, 0x500000uLL);
    if ( !v17 )
    {
      puts("malloc failed for gzip_buf!");
      return 0xFFFFFFFFLL;
    }
    v11 = sub_4097A8((__int64)v17, 5242880, v16, &v5);
    if ( v11 < 0 )
    {
      printf("Failed to decompress gzipped dtb: %d!\n");
      free(v17);
      return 0xFFFFFFFFLL;
    }
    v16 = v17;
    v15 = *v17;
  }
  if ( v15 == -302117424 )
  {
    sub_401DE0((unsigned int *)v16, v3);
    sub_40B95C((unsigned int *)v16);
    *(_DWORD *)(v4 + 262140) = sub_401E48(v4);
  }
  else if ( v15 == 1598836033 )
  {
    v13 = 0;
    v10 = v16[1];
    if ( v10 == 1 )
    {
      v13 = 4;
    }
    else if ( v10 == 2 )
    {
      v13 = 16;
    }
    v9 = 3 * v13;
    v8 = 3 * v13 + 8;
    v12 = v16[2];
    for ( i = 0; v12 > i; ++i )
    {
      v7 = *(int *)((char *)v16 + i * v8 + (unsigned __int64)v9 + 12);
      if ( *(int *)((char *)v16 + v7) == -302117424 )
      {
        sub_401DE0((unsigned int *)((char *)v16 + v7), v3);
        sub_40B95C((unsigned int *)((char *)v16 + v7));
      }
    }
    *(_DWORD *)(v4 + 262140) = sub_401E48(v4);
  }
  if ( v17 )
  {
    v11 = sub_40976C(v4, &v6, (__int64)v17, v5);
    if ( v11 < 0 )
    {
      printf("Failed to compress data to dtb: %d!\n");
      free(v17);
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)(v4 + 262140) = sub_401E48(v4);
    free(v17);
  }
  return 0LL;
}

//----- (000000000040283C) ----------------------------------------------------
signed __int64 __fastcall sub_40283C(void **a1, const char *a2)
{
  signed __int64 result; // x0
  const char *v3; // [xsp+10h] [xbp+10h]
  void **v4; // [xsp+18h] [xbp+18h]
  FILE *v5; // [xsp+28h] [xbp+28h]

  v4 = a1;
  v3 = a2;
  if ( !sub_40166C(a2) & 0xFF )
  {
    printf("Partition '%s' does not exist!\n");
    result = 0xFFFFFFFFLL;
  }
  else
  {
    *v4 = calloc(1uLL, 0x518uLL);
    if ( *v4 )
    {
      v5 = fopen(v3, "rb");
      if ( v5 )
      {
        if ( (unsigned int)fseek(v5, 0LL, 0) )
        {
          puts("Error seek file!");
          free(*v4);
          *v4 = 0LL;
          fclose(v5);
          result = 0xFFFFFFFFLL;
        }
        else if ( fread(*v4, 0x518uLL, 1uLL, v5) == 1 )
        {
          fclose(v5);
          result = 0LL;
        }
        else
        {
          puts("Error reading file!");
          free(*v4);
          *v4 = 0LL;
          fclose(v5);
          result = 0xFFFFFFFFLL;
        }
      }
      else
      {
        printf("Error opening file for reading '%s'!\n");
        free(*v4);
        *v4 = 0LL;
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      puts("malloc failed for struct mmc_partitions_fmt!");
      result = 0xFFFFFFFFLL;
    }
  }
  return result;
}

//----- (00000000004029B4) ----------------------------------------------------
signed __int64 __fastcall sub_4029B4(const void *a1, const char *a2)
{
  signed __int64 result; // x0
  const void *v3; // [xsp+18h] [xbp+18h]
  void *v4; // [xsp+28h] [xbp+28h]
  FILE *v5; // [xsp+30h] [xbp+30h]
  unsigned int i; // [xsp+3Ch] [xbp+3Ch]

  v3 = a1;
  v5 = fopen(a2, "rb+");
  if ( v5 )
  {
    v4 = calloc(1uLL, 0x40000uLL);
    if ( v4 )
    {
      for ( i = 0; i <= 1; ++i )
      {
        if ( (unsigned int)fseek(v5, (i + 16LL) << 18, 0) )
        {
          puts("Error seek file!");
          free(v4);
          fclose(v5);
          return 0xFFFFFFFFLL;
        }
        if ( fread(v4, 0x40000uLL, 1uLL, v5) != 1 )
        {
          puts("Error reading file!");
          free(v4);
          fclose(v5);
          return 0xFFFFFFFFLL;
        }
        if ( (signed int)sub_402520((int *)v4, "/partitions") < 0 )
        {
          printf("Could not remove node '%s' from dtb%d!\n");
          free(v4);
          fclose(v5);
          return 0xFFFFFFFFLL;
        }
        if ( (unsigned int)fseek(v5, (i + 16LL) << 18, 0) )
        {
          puts("Error seek file!");
          free(v4);
          fclose(v5);
          return 0xFFFFFFFFLL;
        }
        if ( fwrite(v4, 0x40000uLL, 1uLL, v5) != 1 )
        {
          puts("Error writing file!");
          free(v4);
          fclose(v5);
          return 0xFFFFFFFFLL;
        }
      }
      free(v4);
      if ( (unsigned int)fseek(v5, 0LL, 0) )
      {
        puts("Error seek file!");
        fclose(v5);
        result = 0xFFFFFFFFLL;
      }
      else if ( fwrite(v3, 0x518uLL, 1uLL, v5) == 1 )
      {
        fflush(v5);
        fclose(v5);
        result = 0LL;
      }
      else
      {
        puts("Error writing file!");
        fclose(v5);
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      puts("malloc failed for dtb!");
      fclose(v5);
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    printf("Error opening file for writing '%s'!\n");
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (0000000000402C3C) ----------------------------------------------------
signed __int64 __fastcall run_command(const char *a1, void *a2, FILE *a3)
{
  const char *v3; // ST28_8
  signed __int64 result; // x0
  __int64 v5; // x0
  char v6; // w2
  FILE *v7; // [xsp+18h] [xbp-2838h]
  void *v8; // [xsp+20h] [xbp-2830h]
  char v9[10244]; // [xsp+38h] [xbp-2818h]
  int v10; // [xsp+283Ch] [xbp-14h]
  FILE *v11; // [xsp+2840h] [xbp-10h]
  size_t v12; // [xsp+2848h] [xbp-8h]

  v3 = a1;
  v8 = a2;
  v7 = a3;
  v12 = 0LL;
  memset(v9, 0, 0x2800uLL);
  v11 = popen(v3, "r");
  if ( v11 )
  {
    while ( !(unsigned int)feof(v11) )
    {
      v10 = getc(v11);
      if ( v10 == -1 )
        break;
      if ( v7 )
      {
        fputc(v10, v7);
        fflush(v7);
      }
      if ( v12 <= 0x27FF )
      {
        v5 = v12++;
        v9[v5] = v10;
      }
    }
    if ( v9[v12 - 1] == 10 )
      v6 = 0;
    else
      v6 = v9[v12 - 1];
    v9[v12 - 1] = v6;
    if ( v8 )
      memcpy(v8, v9, v12);
    if ( (signed int)pclose(v11) >= 0 )
    {
      result = 0LL;
    }
    else
    {
      puts("Error running pclose on cmd");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    puts("Error running cmd with popen");
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 402C3C: using guessed type char var_2818[10244];

//----- (0000000000402DB0) ----------------------------------------------------
signed __int64 __fastcall sub_402DB0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // ST20_8
  __int64 v7; // [xsp+18h] [xbp-2828h]
  char v8; // [xsp+40h] [xbp-2800h]

  v5 = a4;
  v7 = a5;
  memset(&v8, 0, 0x2800uLL);
  printf("\nStarting to format the new '%s' partition...\n");
  if ( v5 && v7 )
    snprintf(&v8, 0x2800uLL, "mke2fs -F -L \"%s\" -t ext4 -m 0 \"%s\" -O %s -E offset=%lld %lldm; sync");
  else
    snprintf(&v8, 0x2800uLL, "mke2fs -F -L \"%s\" -t ext4 -m 0 \"%s\" -O %s; sync");
  if ( (signed int)run_command(&v8, 0LL, (FILE *)stdout) >= 0 )
    return 0LL;
  printf("Error executing cmd '%s'\n");
  return 0xFFFFFFFFLL;
}
// 422218: using guessed type __int64 stdout;

//----- (0000000000402EC0) ----------------------------------------------------
signed __int64 __fastcall sub_402EC0(__int64 a1, const char *a2)
{
  signed __int64 result; // x0
  __int64 v3; // [xsp+10h] [xbp+10h]
  __int64 v4; // [xsp+18h] [xbp+18h]
  int v5; // [xsp+2Ch] [xbp+2Ch]

  v4 = a1;
  v3 = (__int64)a2;
  if ( (signed int)sub_401FAC(a1, a2, (unsigned int *)&v5) >= 0 )
  {
    if ( (signed int)sub_402DB0(
                       v3,
                       (__int64)"/dev/mmcblk0",
                       (__int64)"none,has_journal,ext_attr,resize_inode,dir_index,filetype,extent,flex_bg,sparse_super,la"
                                "rge_file,huge_file,dir_nlink,extra_isize",
                       *(_QWORD *)(v4 + 40LL * v5 + 48),
                       *(_QWORD *)(v4 + 40LL * v5 + 40)) >= 0 )
    {
      result = 0LL;
    }
    else
    {
      printf("Failed to format ext4 '%s' partition!\n");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    printf("Could not find '%s' partition!\n");
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (0000000000402F94) ----------------------------------------------------
signed __int64 format_vfat_partition()
{
  char v1; // [xsp+20h] [xbp-2800h]

  memset(&v1, 0, 0x2800uLL);
  printf("\nStarting to format the new '%s' partition...\n");
  snprintf(&v1, 0x2800uLL, "mkfs.vfat -n \"%s\" %s; sync");
  if ( (signed int)run_command(&v1, 0LL, (FILE *)stdout) >= 0 )
    return 0LL;
  printf("Error executing cmd '%s'\n");
  return 0xFFFFFFFFLL;
}
// 422218: using guessed type __int64 stdout;

//----- (0000000000403044) ----------------------------------------------------
signed __int64 __fastcall sub_403044(__int64 a1, const char *a2)
{
  const char *v2; // ST10_8
  signed __int64 result; // x0
  __int64 v4; // x6
  __int64 v5; // x5
  __int64 v6; // [xsp+18h] [xbp+18h]
  char v7; // [xsp+28h] [xbp+28h]
  char v8; // [xsp+228h] [xbp+228h]
  int v9; // [xsp+32Ch] [xbp+32Ch]

  v6 = a1;
  v2 = a2;
  memset(&v8, 0, 0x100uLL);
  memset(&v7, 0, 0x200uLL);
  if ( (signed int)sub_401FAC(v6, v2, (unsigned int *)&v9) >= 0 )
  {
    if ( (signed int)run_command("losetup --find", &v8, 0LL) >= 0 )
    {
      v4 = *(_QWORD *)(v6 + 40LL * v9 + 40);
      v5 = *(_QWORD *)(v6 + 40LL * v9 + 48);
      snprintf(&v7, 0x200uLL, "losetup %s %s --offset %lld --sizelimit %lld");
      if ( (signed int)run_command(&v7, 0LL, 0LL) >= 0 )
      {
        if ( (signed int)format_vfat_partition() >= 0 )
        {
          result = 0LL;
        }
        else
        {
          printf("Failed to format vfat '%s' partition!\n");
          result = 0xFFFFFFFFLL;
        }
      }
      else
      {
        printf("Error executing cmd '%s'\n");
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      puts("Error getting next free loop");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    printf("Could not find '%s' partition!\n");
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (00000000004031D4) ----------------------------------------------------
signed __int64 __fastcall sub_4031D4(const char *a1)
{
  const char *v1; // ST18_8
  char v3; // [xsp+20h] [xbp+20h]
  char v4; // [xsp+220h] [xbp+220h]

  v1 = a1;
  memset(&v4, 0, 0x200uLL);
  memset(&v3, 0, 0x200uLL);
  if ( !stat(v1) )
    return 0LL;
  snprintf(&v3, 0x200uLL, "grep %s /proc/mounts");
  if ( (signed int)run_command(&v3, &v4, 0LL) >= 0 )
    return v4 != 0;
  printf("Error executing cmd '%s'\n");
  return 0xFFFFFFFFLL;
}

//----- (000000000040329C) ----------------------------------------------------
signed __int64 __fastcall sub_40329C(const char *a1)
{
  signed __int64 result; // x0
  const char *v2; // [xsp+18h] [xbp+18h]
  char v3; // [xsp+28h] [xbp+28h]
  int v4; // [xsp+22Ch] [xbp+22Ch]

  v2 = a1;
  memset(&v3, 0, 0x200uLL);
  if ( !stat(v2) )
    return 0LL;
  v4 = sub_4031D4(v2);
  if ( v4 >= 0 )
  {
    if ( v4 )
    {
      snprintf(&v3, 0x200uLL, "umount %s");
      if ( (signed int)run_command(&v3, 0LL, 0LL) >= 0 )
      {
        result = 0LL;
      }
      else
      {
        printf("Error executing cmd '%s'\n");
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      result = 0LL;
    }
  }
  else
  {
    printf("Error checking if path is mounted: '%s'\n");
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000040337C) ----------------------------------------------------
signed __int64 __fastcall sub_40337C(__int64 a1, __int64 a2, void *a3)
{
  void *v3; // ST18_8
  char v5; // [xsp+30h] [xbp-2800h]

  v3 = a3;
  memset(&v5, 0, 0x2800uLL);
  snprintf(&v5, 0x2800uLL, "grep %s /proc/mounts | awk '{print $%d}'");
  if ( (signed int)run_command(&v5, v3, 0LL) >= 0 )
    return 0LL;
  printf("Error executing cmd '%s'\n");
  return 0xFFFFFFFFLL;
}

//----- (0000000000403418) ----------------------------------------------------
signed __int64 __fastcall sub_403418(__int64 a1, const char *a2, const char *a3)
{
  const char *v3; // ST20_8
  signed __int64 result; // x0
  __int64 v5; // x5
  const char *v6; // [xsp+18h] [xbp+18h]
  __int64 v7; // [xsp+28h] [xbp+28h]
  char v8; // [xsp+38h] [xbp+38h]
  char v9; // [xsp+238h] [xbp+238h]
  int v10; // [xsp+33Ch] [xbp+33Ch]

  v7 = a1;
  v3 = a2;
  v6 = a3;
  memset(&v9, 0, 0x100uLL);
  memset(&v8, 0, 0x200uLL);
  if ( (signed int)sub_401FAC(v7, v3, (unsigned int *)&v10) >= 0 )
  {
    if ( (signed int)run_command("losetup --find", &v9, 0LL) >= 0 )
    {
      v5 = *(_QWORD *)(v7 + 40LL * v10 + 48);
      snprintf(&v8, 0x200uLL, "losetup %s %s --offset %lld");
      if ( (signed int)run_command(&v8, 0LL, 0LL) >= 0 )
      {
        if ( (signed int)sub_40329C(v6) >= 0 )
        {
          snprintf(&v8, 0x200uLL, "mkdir -p %s");
          if ( (signed int)run_command(&v8, 0LL, 0LL) >= 0 )
          {
            snprintf(&v8, 0x200uLL, "mount -o rw,loop %s %s");
            if ( (signed int)run_command(&v8, 0LL, 0LL) >= 0 )
            {
              result = 0LL;
            }
            else
            {
              printf("Error executing cmd '%s'\n");
              result = 0xFFFFFFFFLL;
            }
          }
          else
          {
            printf("Error executing cmd '%s'\n");
            result = 0xFFFFFFFFLL;
          }
        }
        else
        {
          printf("Failed to umount folder '%s'\n");
          result = 0xFFFFFFFFLL;
        }
      }
      else
      {
        printf("Error executing cmd '%s'\n");
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      puts("Error getting next free loop");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    printf("Could not find '%s' partition!\n");
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (0000000000403624) ----------------------------------------------------
signed __int64 __fastcall sub_403624(const char *a1)
{
  const char *v2; // [xsp+18h] [xbp+18h]
  char v3; // [xsp+20h] [xbp+20h]

  v2 = a1;
  memset(&v3, 0, 0x200uLL);
  if ( !v2 )
    return 0LL;
  if ( !stat(v2) )
    return 0LL;
  snprintf(&v3, 0x200uLL, "rm -rf %s/* %s/.* 2>&1");
  if ( (signed int)run_command(&v3, 0LL, 0LL) >= 0 )
    return 0LL;
  printf("Error executing cmd '%s'\n");
  return 0xFFFFFFFFLL;
}

//----- (00000000004036D8) ----------------------------------------------------
signed __int64 __fastcall sub_4036D8(const char *a1)
{
  const char *v2; // [xsp+18h] [xbp+18h]
  char v3; // [xsp+20h] [xbp+20h]

  v2 = a1;
  memset(&v3, 0, 0x200uLL);
  if ( !v2 )
    return 0LL;
  if ( !stat(v2) )
    return 0LL;
  snprintf(&v3, 0x200uLL, "rm -rf %s/ 2>&1");
  if ( (signed int)run_command(&v3, 0LL, 0LL) >= 0 )
    return 0LL;
  printf("Error executing cmd '%s'\n");
  return 0xFFFFFFFFLL;
}

//----- (0000000000403788) ----------------------------------------------------
signed __int64 sub_403788()
{
  signed __int64 result; // x0
  char v1; // [xsp+20h] [xbp+20h]

  memset(&v1, 0, 0x200uLL);
  snprintf(&v1, 0x200uLL, "rsync -ah --info=progress2 %s/ %s/");
  printf("Copy all data from '%s' to '%s'\n");
  if ( (signed int)run_command(&v1, 0LL, (FILE *)stdout) >= 0 )
  {
    puts("\nSyncthing, please wait...");
    fflush((FILE *)stdout);
    if ( (signed int)run_command("sync", 0LL, 0LL) >= 0 )
    {
      result = 0LL;
    }
    else
    {
      printf("Error executing cmd '%s'\n");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    printf("Error executing cmd '%s'\n");
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 422218: using guessed type __int64 stdout;

//----- (0000000000403888) ----------------------------------------------------
signed __int64 __fastcall sub_403888(__int64 a1, const char *a2)
{
  const char *v2; // ST10_8
  signed __int64 result; // x0
  char v4; // [xsp+20h] [xbp+20h]

  v2 = a2;
  memset(&v4, 0, 0x200uLL);
  if ( (signed int)sub_4036D8(v2) >= 0 )
  {
    snprintf(&v4, 0x200uLL, "mkdir -p %s");
    if ( (signed int)run_command(&v4, 0LL, 0LL) >= 0 )
    {
      if ( (signed int)sub_403788() >= 0 )
      {
        result = 0LL;
      }
      else
      {
        printf("Failed to copy data from '%s' to '%s'\n");
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      printf("Error executing cmd '%s'\n");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    printf("Failed to remove folder '%s'\n");
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (0000000000403968) ----------------------------------------------------
signed __int64 __fastcall sub_403968(__int64 a1, char a2)
{
  signed __int64 result; // x0
  char v3; // [xsp+17h] [xbp-2A19h]
  __int64 v4; // [xsp+18h] [xbp-2A18h]
  char v5[512]; // [xsp+20h] [xbp-2A10h]
  char v6; // [xsp+220h] [xbp-2810h]
  char v7; // [xsp+2A27h] [xbp-9h]
  char *i; // [xsp+2A28h] [xbp-8h]

  v4 = a1;
  v3 = a2;
  memset(&v6, 0, 0x2800uLL);
  memset(v5, 0, 0x200uLL);
  i = 0LL;
  if ( (signed int)sub_40337C(v4, 2LL, &v6) >= 0 )
  {
    for ( i = strtok(&v6, "\n"); i; i = strtok(0LL, "\n") )
    {
      if ( v3 )
      {
        if ( (signed int)sub_40337C((__int64)i, 1LL, v5) < 0 )
        {
          printf("Error getting info from /proc/mount for '%s'\n");
          return 0xFFFFFFFFLL;
        }
        v7 = v5[strlen(v5) - 1];
      }
      if ( (signed int)sub_40329C(i) < 0 )
      {
        printf("Could not umount path '%s' of device '%s'!\n");
        return 0xFFFFFFFFLL;
      }
      if ( v3 )
      {
        snprintf(v5, 0x200uLL, "parted -s \"/dev/%s\" rm %c");
        if ( (signed int)run_command(v5, 0LL, 0LL) < 0 )
        {
          printf("Error executing cmd '%s'\n");
          return 0xFFFFFFFFLL;
        }
      }
      if ( (signed int)sub_4036D8(i) < 0 )
      {
        printf("Failed to remove folder '%s'\n");
        return 0xFFFFFFFFLL;
      }
    }
    result = 0LL;
  }
  else
  {
    printf("Error getting info from /proc/mount for '%s'\n");
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 403968: using guessed type char var_2A10[512];

//----- (0000000000403B48) ----------------------------------------------------
signed __int64 __fastcall sub_403B48(__int64 a1, __int64 a2)
{
  __int64 v2; // ST18_8
  __int64 v4; // [xsp+10h] [xbp+10h]

  v2 = a1;
  v4 = a2;
  putchar(10);
  puts("Starting copying of data to the eMMC!");
  puts("Please do \x1B[1mNOT\x1B[0m interrupt this progress till it's finished!\n");
  if ( v2 )
  {
    if ( (signed int)sub_403624("/media/RETROLX") < 0 )
    {
      printf("Failed to remove content of folder '%s'\n");
      return 0xFFFFFFFFLL;
    }
    if ( (signed int)sub_403788() < 0 )
    {
      printf("Failed to copy data from '%s' to '%s'\n");
      return 0xFFFFFFFFLL;
    }
  }
  if ( !v4 )
    return 0LL;
  if ( (signed int)sub_4036D8("/media/SHARE/coreelec_storage") < 0 )
  {
    printf("Failed to remove folder '%s'\n");
    return 0xFFFFFFFFLL;
  }
  if ( (signed int)sub_403788() >= 0 )
    return 0LL;
  printf("Failed to copy data from '%s' to '%s'\n");
  return 0xFFFFFFFFLL;
}

//----- (0000000000403C6C) ----------------------------------------------------
signed __int64 sub_403C6C()
{
  signed __int64 result; // x0

  if ( (signed int)sub_40329C("/media/RETROLX") >= 0 )
  {
    if ( (signed int)sub_40329C("/media/SHARE") >= 0 )
    {
      result = 0LL;
    }
    else
    {
      printf("Failed to umount folder '%s'\n");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    printf("Failed to umount folder '%s'\n");
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (0000000000403CE0) ----------------------------------------------------
__int64 __fastcall sub_403CE0(const char *a1)
{
  const char *v2; // [xsp+18h] [xbp+18h]
  char v3; // [xsp+28h] [xbp+28h]
  __int64 v4; // [xsp+30h] [xbp+30h]
  __int64 v5; // [xsp+48h] [xbp+48h]

  v2 = a1;
  if ( !stat(a1) )
    return 0LL;
  if ( (unsigned int)statfs(v2, (struct statfs *)&v3) )
    return 0LL;
  return v5 * v4;
}

//----- (0000000000403D38) ----------------------------------------------------
signed __int64 __fastcall sub_403D38(const char *a1, __int64 *a2)
{
  const char *v2; // ST18_8
  signed __int64 result; // x0
  __int64 *v4; // [xsp+10h] [xbp+10h]
  char v5; // [xsp+20h] [xbp+20h]

  v2 = a1;
  v4 = a2;
  memset(&v5, 0, 0x200uLL);
  if ( !stat(v2) )
    return 0xFFFFFFFFLL;
  snprintf(
    (char *)qword_422230,
    0x2800uLL,
    "rsync --dry-run -av %s/ backup/ | tail -n 1 | awk '{print $4}' | sed 's/,//g'");
  if ( (signed int)run_command((const char *)qword_422230, &v5, 0LL) >= 0 )
  {
    if ( v4 )
      *v4 = strtoll(&v5, 0LL, 10);
    result = 0LL;
  }
  else
  {
    printf("Error executing cmd '%s'\n");
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 422230: using guessed type __int64 qword_422230;

//----- (0000000000403E18) ----------------------------------------------------
__int64 sub_403E18()
{
  __int64 result; // x0
  FILE *v1; // [xsp+20h] [xbp+20h]
  __int64 v2; // [xsp+28h] [xbp+28h]

  v2 = 0LL;
  snprintf((char *)qword_422230, 0x2800uLL, "/sys/block/%s/size");
  if ( !sub_40166C((const char *)qword_422230) & 0xFF )
  {
    printf("Parameter for block device '%s' not found: '%s'\n");
    result = 0LL;
  }
  else
  {
    v1 = fopen((const char *)qword_422230, "r");
    if ( v1 )
    {
      if ( fgets((char *)qword_422230, 10240, v1) )
        v2 = strtoll((const char *)qword_422230, 0LL, 10) << 9;
      fclose(v1);
    }
    result = v2;
  }
  return result;
}
// 422230: using guessed type __int64 qword_422230;

//----- (0000000000403F18) ----------------------------------------------------
__int64 __fastcall sub_403F18(__int64 a1, const char *a2)
{
  __int64 v2; // ST28_8

  v2 = sub_403CE0(a2);
  printf("Free space of '%s': %lldMB\n");
  return v2;
}

//----- (0000000000403F5C) ----------------------------------------------------
signed __int64 __fastcall sub_403F5C(__int64 a1, const char *a2, __int64 *a3)
{
  signed __int64 result; // x0
  unsigned __int64 v4; // x2
  __int64 *v5; // [xsp+18h] [xbp+18h]

  v5 = a3;
  if ( (signed int)sub_403D38(a2, a3) >= 0 )
  {
    v4 = (unsigned __int64)((unsigned __int64)*v5 * (unsigned __int128)0x431BDE82D7B634DBuLL >> 64) >> 18;
    printf("Used space of '%s': %lldMB\n");
    result = 0LL;
  }
  else
  {
    printf("Failed to get used space of path '%s'!\n");
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (0000000000403FDC) ----------------------------------------------------
signed __int64 __fastcall sub_403FDC(__int64 a1, const char *a2, _QWORD *a3)
{
  signed __int64 result; // x0
  _QWORD *v4; // [xsp+18h] [xbp+18h]
  __int64 v5; // [xsp+28h] [xbp+28h]
  int v6; // [xsp+3Ch] [xbp+3Ch]

  v5 = a1;
  v4 = a3;
  if ( (signed int)sub_401FAC(a1, a2, (unsigned int *)&v6) >= 0 )
  {
    if ( v4 )
      *v4 = *(_QWORD *)(v5 + 40LL * v6 + 40);
    result = 0LL;
  }
  else
  {
    printf("Could not find '%s' partition!\n");
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (0000000000404068) ----------------------------------------------------
signed __int64 __fastcall sub_404068(__int64 a1, const char *a2, __int64 *a3)
{
  signed __int64 result; // x0
  __int64 *v4; // [xsp+18h] [xbp+18h]

  v4 = a3;
  if ( (signed int)sub_403418(a1, a2, "/media/SHARE") >= 0 )
  {
    snprintf((char *)qword_422230, 0x2800uLL, "partition %s");
    if ( v4 )
      *v4 = sub_403F18(qword_422230, "/media/SHARE");
    if ( (signed int)sub_403C6C() >= 0 )
    {
      result = 0LL;
    }
    else
    {
      puts("Failed to umount temporary CoreELEC folder");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    printf("Failed to mount '%s' partition!\n");
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 422230: using guessed type __int64 qword_422230;

//----- (0000000000404134) ----------------------------------------------------
signed __int64 __fastcall sub_404134(const char *a1, int a2)
{
  int v2; // w19
  __int64 v3; // x1
  __int64 v4; // x19
  __int128 v6; // ST48_16
  int v7; // [xsp+34h] [xbp+34h]
  const char *v8; // [xsp+38h] [xbp+38h]
  signed int v9; // [xsp+68h] [xbp+68h]
  unsigned int i; // [xsp+6Ch] [xbp+6Ch]

  v8 = a1;
  v7 = a2;
  if ( (unsigned int)strcmp(a1, "MPT")
    || !*((_DWORD *)v8 + 4)
    || *((_DWORD *)v8 + 4) > 0x20u
    || (v2 = *((_DWORD *)v8 + 5), v2 != (unsigned int)sub_401EC0((_DWORD *)v8 + 6, *((_DWORD *)v8 + 4))) )
  {
    if ( (unsigned int)strcmp(v8, "MPT") )
    {
      printf("magic error: %s\n");
    }
    else if ( *((_DWORD *)v8 + 4) <= 0x20u )
    {
      v4 = *((unsigned int *)v8 + 5);
      sub_401EC0((_DWORD *)v8 + 6, *((_DWORD *)v8 + 4));
      printf("checksum error: pt_fmt->checksum=%#x,calc_result=%#x\n");
    }
    else
    {
      v3 = *((unsigned int *)v8 + 4);
      printf("partition number error: %d\n");
    }
    puts("partition verified error");
    v9 = -1;
  }
  else
  {
    v9 = 0;
  }
  if ( v9 )
    return 0xFFFFFFFFLL;
  for ( i = v7 - 1; i < *((_DWORD *)v8 + 4) && i <= 0x1F; ++i )
  {
    v6 = *(_OWORD *)&v8[40 * i + 40];
    sub_401F4C(*(_QWORD *)&v8[40 * i + 56]);
    printf("[mmcblk0p%02d] %20s  offset 0x%012llx, size 0x%012llx [%lu MB], %s\n");
    if ( dword_4221E4 >= 0 && ++dword_42222C >= dword_4221E4 )
    {
      putchar(10);
      fflush((FILE *)stdout);
      MEMORY[0] = 10;
    }
  }
  return 0LL;
}
// 4221E4: using guessed type int dword_4221E4;
// 422218: using guessed type __int64 stdout;
// 42222C: using guessed type int dword_42222C;

//----- (00000000004043E8) ----------------------------------------------------
signed __int64 __fastcall sub_4043E8(__int64 a1, const char *a2)
{
  const char *v2; // ST10_8
  signed __int64 result; // x0
  __int64 v4; // x5
  __int64 v5; // x4
  __int64 v6; // [xsp+18h] [xbp+18h]
  int v7; // [xsp+2Ch] [xbp+2Ch]
  char v8; // [xsp+30h] [xbp+30h]

  v6 = a1;
  v2 = a2;
  memset(&v8, 0, 0x100uLL);
  if ( (signed int)sub_401FAC(v6, v2, (unsigned int *)&v7) >= 0 )
  {
    if ( (signed int)run_command("losetup --find", &v8, 0LL) >= 0 )
    {
      v4 = *(_QWORD *)(v6 + 40LL * v7 + 48);
      snprintf((char *)qword_422230, 0x2800uLL, "losetup %s %s --offset %lld");
      if ( (signed int)run_command((const char *)qword_422230, 0LL, 0LL) >= 0 )
      {
        snprintf((char *)qword_422230, 0x2800uLL, "e2fsck -fy %s");
        if ( (signed int)run_command((const char *)qword_422230, 0LL, 0LL) >= 0 )
        {
          putchar(10);
          v5 = *(_QWORD *)(v6 + 40LL * v7 + 40) >> 20;
          snprintf((char *)qword_422230, 0x2800uLL, "resize2fs %s %lldM");
          if ( (signed int)run_command((const char *)qword_422230, 0LL, 0LL) >= 0 )
          {
            result = 0LL;
          }
          else
          {
            printf("Error executing cmd '%s'\n");
            result = 0xFFFFFFFFLL;
          }
        }
        else
        {
          printf("Error executing cmd '%s'\n");
          result = 0xFFFFFFFFLL;
        }
      }
      else
      {
        printf("Error executing cmd '%s'\n");
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      puts("Error getting next free loop");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    printf("Could not find '%s' partition!\n");
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 422230: using guessed type __int64 qword_422230;

//----- (0000000000404628) ----------------------------------------------------
char *__fastcall sub_404628(__int64 a1, char *a2)
{
  __int64 v2; // x1
  int v3; // w1
  char *result; // x0
  char *v5; // [xsp+10h] [xbp+10h]
  __int64 v6; // [xsp+18h] [xbp+18h]
  const char *v7; // [xsp+20h] [xbp+20h]
  unsigned int i; // [xsp+2Ch] [xbp+2Ch]

  v6 = a1;
  v5 = a2;
  memset(a2, 0, 0x518uLL);
  v2 = *(_QWORD *)(v6 + 8);
  *(_QWORD *)v5 = *(_QWORD *)v6;
  *((_QWORD *)v5 + 1) = v2;
  for ( i = 0; i < *(_DWORD *)(v6 + 16); ++i )
  {
    v7 = (const char *)(v6 + 40LL * i + 16 + 8);
    if ( v6 + 40LL * i + 16 != -8 && v7 != (const char *)&unk_40CF50 )
    {
      if ( (unsigned int)strcmp("SHARE", v7) )
      {
        if ( (unsigned int)strcmp("RETROLX", v7) )
        {
          memcpy(&v5[40 * i + 24], (const void *)(v6 + 40LL * i + 16 + 8), 0x28uLL);
          if ( !(unsigned int)strcmp("data", v7) )
            *(_QWORD *)&v5[40 * i + 40] += 0x80000000LL;
        }
      }
    }
  }
  *((_DWORD *)v5 + 4) = *(_DWORD *)(v6 + 16) - 2;
  v3 = sub_401EC0((_DWORD *)v5 + 6, *((_DWORD *)v5 + 4));
  result = v5;
  *((_DWORD *)v5 + 5) = v3;
  return result;
}

//----- (0000000000404804) ----------------------------------------------------
signed __int64 __fastcall sub_404804(const void *a1, int *a2)
{
  signed __int64 result; // x0
  int *v3; // [xsp+10h] [xbp+10h]
  __int64 v4; // [xsp+18h] [xbp+18h]
  int v5; // [xsp+2Ch] [xbp+2Ch]

  v4 = (__int64)a1;
  v3 = a2;
  memcpy(a2, a1, 0x518uLL);
  if ( (signed int)sub_401FAC(v4, "data", (unsigned int *)&v5) >= 0 )
  {
    *(_QWORD *)(v4 + 40LL * v5 + 40) -= 0x80000000LL;
    *(_QWORD *)&v3[10 * v5 + 10] -= 0x80000000LL;
    memcpy(&v3[10 * v3[4] + 6], (const void *)(v4 + 40LL * v5 + 16 + 8), 0x28uLL);
    strncpy((char *)&v3[10 * v3[4] + 6], "SHARE", 0x10uLL);
    strncpy((char *)&v3[10 * ++v3[4] + 6], "RETROLX", 0x10uLL);
    *(_QWORD *)&v3[10 * v3[4] + 12] = *(_QWORD *)&v3[10 * (v3[4] - 1) + 12] + *(_QWORD *)&v3[10 * (v3[4] - 1) + 10];
    *(_QWORD *)&v3[10 * v3[4] + 10] = 0x80000000LL;
    *(_QWORD *)&v3[10 * v3[4]++ + 14] = 4LL;
    v3[5] = sub_401EC0(v3 + 6, v3[4]);
    result = 0LL;
  }
  else
  {
    printf("Could not find '%s' partition!\n");
    result = 0xFFFFFFFFLL;
  }
  return result;
}

//----- (0000000000404B1C) ----------------------------------------------------
signed __int64 __fastcall sub_404B1C(_QWORD *a1, char *a2)
{
  __int64 v2; // x1
  char *v4; // x1
  char *v5; // [xsp+10h] [xbp+10h]
  _QWORD *v6; // [xsp+18h] [xbp+18h]
  int v7; // [xsp+28h] [xbp+28h]
  int v8; // [xsp+2Ch] [xbp+2Ch]
  __int64 v9; // [xsp+30h] [xbp+30h]
  __int64 v10; // [xsp+38h] [xbp+38h]
  int v11; // [xsp+40h] [xbp+40h]
  unsigned int i; // [xsp+44h] [xbp+44h]
  __int64 v13; // [xsp+48h] [xbp+48h]

  v6 = a1;
  v5 = a2;
  v13 = 0LL;
  v10 = 0LL;
  v9 = 0LL;
  memset(a2, 0, 0x518uLL);
  v2 = v6[1];
  *(_QWORD *)v5 = *v6;
  *((_QWORD *)v5 + 1) = v2;
  if ( (signed int)sub_401FAC((__int64)v6, "bootloader", (unsigned int *)&v8) < 0 )
  {
    printf("No bootloader partition found!");
    return 0xFFFFFFFFLL;
  }
  memcpy(&v5[40 * *((unsigned int *)v5 + 4) + 24], &v6[5 * v8 + 3], 0x28uLL);
  v13 = *(_QWORD *)&v5[40 * (*((_DWORD *)v5 + 4))++ + 40];
  if ( (signed int)sub_401FAC((__int64)v6, "reserved", (unsigned int *)&v8) < 0 )
  {
    printf("No reserved partition found!");
    return 0xFFFFFFFFLL;
  }
  v10 = v6[5 * v8 + 6];
  v9 = v6[5 * v8 + 5];
  v11 = 1;
  for ( i = 0; i <= 4; ++i )
  {
    if ( (signed int)sub_401FAC((__int64)v6, (&off_4221F0)[i], (unsigned int *)&v8) >= 0 )
    {
      if ( v11 && (unsigned __int64)(v10 - v13) >= v6[5 * v8 + 5] )
      {
        memcpy(&v5[40 * *((unsigned int *)v5 + 4) + 24], &v6[5 * v8 + 3], 0x28uLL);
        *(_QWORD *)&v5[40 * *((unsigned int *)v5 + 4) + 48] = v13;
        v13 += v6[5 * v8 + 5];
        ++*((_DWORD *)v5 + 4);
      }
      else if ( v11 )
      {
        v11 = 0;
        v13 = v10 + v9;
        if ( (signed int)sub_401FAC((__int64)v6, "reserved", (unsigned int *)&v7) < 0 )
        {
          printf("No reserved partition found!");
          return 0xFFFFFFFFLL;
        }
        memcpy(&v5[40 * *((unsigned int *)v5 + 4) + 24], &v6[5 * v7 + 3], 0x28uLL);
        ++*((_DWORD *)v5 + 4);
      }
      if ( !v11 )
      {
        memcpy(&v5[40 * *((unsigned int *)v5 + 4) + 24], &v6[5 * v8 + 3], 0x28uLL);
        *(_QWORD *)&v5[40 * *((unsigned int *)v5 + 4) + 48] = v13;
        v13 += v6[5 * v8 + 5];
        ++*((_DWORD *)v5 + 4);
      }
    }
    else
    {
      v4 = (&off_4221F0)[i];
      printf("Warning: Could not find '%s' partition!\n");
    }
  }
  if ( v11 )
  {
    if ( (signed int)sub_401FAC((__int64)v6, "reserved", (unsigned int *)&v8) < 0 )
    {
      printf("No reserved partition found!");
      return 0xFFFFFFFFLL;
    }
    if ( v8 >= 0 )
    {
      memcpy(&v5[40 * *((unsigned int *)v5 + 4) + 24], &v6[5 * v8 + 3], 0x28uLL);
      ++*((_DWORD *)v5 + 4);
    }
  }
  strncpy(&v5[40 * *((unsigned int *)v5 + 4) + 24], "RETROLX", 0x10uLL);
  *(_QWORD *)&v5[40 * *((unsigned int *)v5 + 4) + 48] = *(_QWORD *)&v5[40 * (*((_DWORD *)v5 + 4) - 1) + 48]
                                                      + *(_QWORD *)&v5[40 * (*((_DWORD *)v5 + 4) - 1) + 40];
  *(_QWORD *)&v5[40 * *((unsigned int *)v5 + 4) + 40] = 0x80000000LL;
  *(_QWORD *)&v5[40 * (*((_DWORD *)v5 + 4))++ + 56] = 4LL;
  strncpy(&v5[40 * *((unsigned int *)v5 + 4) + 24], "SHARE", 0x10uLL);
  *(_QWORD *)&v5[40 * *((unsigned int *)v5 + 4) + 48] = *(_QWORD *)&v5[40 * (*((_DWORD *)v5 + 4) - 1) + 48]
                                                      + *(_QWORD *)&v5[40 * (*((_DWORD *)v5 + 4) - 1) + 40];
  *(_QWORD *)&v5[40 * *((unsigned int *)v5 + 4) + 40] = sub_403E18()
                                                      - *(_QWORD *)&v5[40 * *((unsigned int *)v5 + 4) + 48];
  *(_QWORD *)&v5[40 * (*((_DWORD *)v5 + 4))++ + 56] = 4LL;
  *((_DWORD *)v5 + 5) = sub_401EC0((_DWORD *)v5 + 6, *((_DWORD *)v5 + 4));
  return 0LL;
}
// 4221F0: using guessed type char *off_4221F0;

//----- (0000000000405384) ----------------------------------------------------
signed __int64 __fastcall create_new_partition_table(int a1, _QWORD *a2, int *a3, _QWORD *a4, __int64 *a5)
{
  unsigned __int64 v6; // x2
  __int64 *v7; // [xsp+18h] [xbp+18h]
  int *v8; // [xsp+28h] [xbp+28h]
  _QWORD *v9; // [xsp+30h] [xbp+30h]
  int v10; // [xsp+3Ch] [xbp+3Ch]

  v10 = a1;
  v9 = a2;
  v8 = a3;
  v7 = a5;
  if ( !a4 || !a5 )
    return 0xFFFFFFFFLL;
  *a4 = 0x80000000LL;
  printf("Free space of 'partition %s': %lldMB\n");
  {
    if ( (signed int)sub_404B1C(v9, (char *)v8) < 0 )
    {
      puts("Failed to create partition table for single boot installation!");
      return 0xFFFFFFFFLL;
    }
    if ( (signed int)sub_403FDC((__int64)v8, "SHARE", v7) < 0 )
    {
      printf("Failed to read size of partition '%s'!\n");
      return 0xFFFFFFFFLL;
    }
    v6 = (unsigned __int64)*v7 >> 20;
    printf("Free space of 'partition %s': %lldMB\n");
  }
  if ( dword_422228 )
  {
    puts("\nNew partition table:");
    if ( (unsigned int)sub_404134((const char *)v8, 1) )
      return 0xFFFFFFFFLL;
  }
  putchar(10);
  return 0LL;
}
// 422228: using guessed type int dword_422228;

//----- (0000000000405550) ----------------------------------------------------
signed __int64 __fastcall install_to_emmc(_QWORD *a1, int a2, int a3)
{
  signed __int64 result; // x0
  int v5; // [xsp+14h] [xbp+14h]
  __int64 v6; // [xsp+18h] [xbp+18h]
  void *v7; // [xsp+20h] [xbp+20h]
  void *v8; // [xsp+28h] [xbp+28h]
  unsigned __int64 v9; // [xsp+30h] [xbp+30h]
  unsigned __int64 v10; // [xsp+38h] [xbp+38h]
  unsigned __int64 v11; // [xsp+40h] [xbp+40h]
  unsigned __int64 v12; // [xsp+48h] [xbp+48h]
  char v13; // [xsp+50h] [xbp+50h]
  const char *v14; // [xsp+568h] [xbp+568h]
  const char *v15; // [xsp+570h] [xbp+570h]
  int v16; // [xsp+57Ch] [xbp+57Ch]

  v6 = (__int64)a1;
  v5 = a2;
  v8 = 0LL;
  v7 = 0LL;
  if ( (signed int)create_new_partition_table(a2, a1, (int *)&v13, &v12, (__int64 *)&v11) < 0 )
  {
    puts("Failed to create new partition table!");
    return 0xFFFFFFFFLL;
  }
  {
    if ( (signed int)sub_403F5C((__int64)"/flash", "/flash", (__int64 *)&v10) < 0 )
    {
      printf("Failed to get used space of path '%s'!\n");
      return 0xFFFFFFFFLL;
    }
    if ( (signed int)sub_403F5C((__int64)"/storage", "/storage", (__int64 *)&v9) < 0 )
    {
      printf("Failed to get used space of path '%s'!\n");
      return 0xFFFFFFFFLL;
    }
  }
  if ( v12 >= v10 )
  {
    if ( v11 >= v9 )
    {
      puts("\nThere is enough free space on eMMC for installation!");
      printf("\nInstall RetroLX on eMMC.\nContinue? [y]: ");
      if ( (unsigned __int8)sub_4015DC() != 121 )
      {
        puts("\nAborting!\n");
        return 0LL;
      }
      if ( v5 == 1 )
      {
        if ( (unsigned int)do_backup(&v8, "/dev/reserved", 0, 1304) )
        {
          puts("Failed to create backup of original partition table!");
          return 0xFFFFFFFFLL;
        }
        if ( (signed int)do_backup(&v7, "/dev/reserved", 0x400000, 0x80000) < 0 )
        {
          puts("Failed to create backup of bootloader dtb!");
          return 0xFFFFFFFFLL;
        }
      }
      if ( (unsigned int)sub_4029B4(&v13, "/dev/reserved") )
      {
        puts("Failed to write the new partition table to eMMC!");
        return 0xFFFFFFFFLL;
      }
      if ( v5 )
      {
        if ( v5 == 1 && (signed int)sub_4043E8((__int64)&v13, "SHARE") < 0 )
        {
          printf("Failed to resize partition '%s'!\n");
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        if ( (signed int)sub_402468(v6, (__int64)&v13) < 0 )
        {
          puts("Failed to move partitions");
          return 0xFFFFFFFFLL;
        }
        if ( (signed int)sub_402EC0((__int64)&v13, "SHARE") < 0 )
        {
          printf("Failed to format partition '%s'!\n");
          return 0xFFFFFFFFLL;
        }
      }
      if ( (signed int)sub_403044((__int64)&v13, "RETROLX") < 0 )
      {
        printf("Failed to format partition '%s'!\n");
        return 0xFFFFFFFFLL;
      }
      if ( (signed int)sub_403418((__int64)&v13, "RETROLX", "/media/RETROLX") < 0 )
      {
        printf("Failed to mount '%s' partition!\n");
        return 0xFFFFFFFFLL;
      }
      if ( (signed int)sub_403418((__int64)&v13, "SHARE", "/media/SHARE") < 0 )
      {
        printf("Failed to mount '%s' partition!\n");
        return 0xFFFFFFFFLL;
      }
      v16 = sub_403B48((__int64)"/flash", (__int64)"/storage");
      if ( v16 >= 0 )
      {
        if ( (signed int)sub_403C6C() >= 0 )
        {
          puts("\nSuccess!\n");
          printf("\nYou can now power off the device, remove the used boot media (SD or USB) and");
          puts("\npower on again to boot the device from eMMC!\n");
          qword_422238 = (__int64)"CEEMMC_NEW";
          result = 0LL;
        }
        else
        {
          puts("Failed to umount temporary RetroLX folder");
          result = 0xFFFFFFFFLL;
        }
      }
      else
      {
        puts("Failed to move data from original media to eMMC");
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      v14 = "/storage";
      printf("New partition is too small to cover data of '%s' from current boot device!\n");
      printf("Free space on '%s' partition: %lldMB\n");
      printf("Used space on '%s': %lld\n");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    v15 = "/flash";
    printf("New partition is too small to cover data of '%s' from current boot device!\n");
    printf("Free space on '%s' partition: %lldMB\n");
    printf("Used space on '%s': %lld\n");
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 422230: using guessed type __int64 qword_422230;
// 422238: using guessed type __int64 qword_422238;

//----- (0000000000405CC8) ----------------------------------------------------
signed __int64 __fastcall sub_405CC8(__int64 a1, int a2)
{
  signed __int64 result; // x0
  int v3; // w0
  int v4; // w0
  int v5; // [xsp+14h] [xbp+14h]
  __int64 v6; // [xsp+18h] [xbp+18h]
  void *v7; // [xsp+28h] [xbp+28h]
  void *v8; // [xsp+30h] [xbp+30h]
  unsigned __int64 v9; // [xsp+38h] [xbp+38h]
  unsigned __int64 v10; // [xsp+40h] [xbp+40h]
  int v11; // [xsp+4Ch] [xbp+4Ch]

  v6 = a1;
  v5 = a2;
  v8 = 0LL;
  v7 = 0LL;
  v10 = 0x80000000LL;
  putchar(10);
  printf("Usable space of 'partition %s': %lldMB\n");
  if ( !v5 )
  {
    if ( (signed int)sub_403F5C((__int64)"/flash", "/flash", (__int64 *)&v9) < 0 )
    {
      printf("Failed to get used space of path '%s'!\n");
      return 0xFFFFFFFFLL;
    }
    goto LABEL_10;
  }
  if ( v5 != 2 )
    goto LABEL_10;
  if ( stat("/storage/backup/eMMC_backup/coreelec_flash") )
  {
    if ( (signed int)sub_403F5C(
                       (__int64)"/storage/backup/eMMC_backup/coreelec_flash",
                       "/storage/backup/eMMC_backup/coreelec_flash",
                       (__int64 *)&v9) < 0 )
    {
      printf("Failed to get used space of path '%s'!\n");
      return 0xFFFFFFFFLL;
    }
LABEL_10:
    if ( v9 + 0x800000 > v10 )
    {
      puts("\nThere is \x1B[1mNOT\x1B[0m enough free space on flash partition on eMMC for installation!");
      return 0xFFFFFFFFLL;
    }
    puts("\nThere is enough free space on flash partition on eMMC for installation!");
    printf("\nWarning!\nALL existing RetroLX data on flash partition on eMMC will be lost!");
    printf("\nnContinue with [y] or press enter to skip flash partition!");
    printf("\nContinue? [y]: ");
    if ( (unsigned __int8)sub_4015DC() == 121 )
    {
      v3 = sub_403418(v6, "RETROLX", "/media/RETROLX");
      if ( v3 < 0 )
      {
        printf("Failed to mount '%s' partition!\n");
        return 0xFFFFFFFFLL;
      }
      if ( v5 )
      {
        if ( v5 == 2 && (signed int)sub_403B48((__int64)"/storage/backup/eMMC_backup/coreelec_flash", 0LL) < 0 )
        {
          printf("Failed to move data from '%s' to eMMC\n");
          return 0xFFFFFFFFLL;
        }
      }
      else if ( (signed int)sub_403B48((__int64)"/flash", 0LL) < 0 )
      {
        printf("Failed to move data from '%s' to eMMC\n");
        return 0xFFFFFFFFLL;
      }
    }
    goto LABEL_23;
  }
  printf("Folder of backup '%s' not found!\n");
LABEL_23:
  if ( (signed int)sub_403FDC(v6, "SHARE", &v10) < 0 )
  {
    printf("Failed to read size of partition '%s'!\n");
    return 0xFFFFFFFFLL;
  }
  putchar(10);
  printf("Usable space of 'partition %s': %lldMB\n");
  if ( v5 )
  {
    if ( v5 == 2 )
    {
      if ( !stat("/storage/backup/eMMC_backup/coreelec_storage") )
      {
        printf("Folder of backup '%s' not found!\n");
        return 0LL;
      }
      if ( (signed int)sub_403F5C(
                         (__int64)"/storage/backup/eMMC_backup/coreelec_storage",
                         "/storage/backup/eMMC_backup/coreelec_storage",
                         (__int64 *)&v9) < 0 )
      {
        printf("Failed to get used space of path '%s'!\n");
        return 0xFFFFFFFFLL;
      }
    }
  }
  else if ( (signed int)sub_403F5C((__int64)"/storage", "/storage", (__int64 *)&v9) < 0 )
  {
    printf("Failed to get used space of path '%s'!\n");
    return 0xFFFFFFFFLL;
  }
  if ( v10 < v9 )
  {
    puts("\nThere is \x1B[1mNOT\x1B[0m enough free space on storage partition on eMMC for installation!");
    return 0xFFFFFFFFLL;
  }
  puts("\nThere is enough free space on storage partition on eMMC for installation!");
  printf("\nWarning!\nALL existing RetroLX data on storage partition on eMMC will be lost!");
  printf("\nContinue with [y] or press enter to skip storage partition!");
  printf("\nContinue? [y]: ");
  if ( (unsigned __int8)sub_4015DC() != 121 )
    goto LABEL_77;
  v4 = sub_403418(v6, "SHARE", "/media/SHARE");
  if ( v4 < 0 )
  {
    printf("Failed to mount '%s' partition!\n");
    return 0xFFFFFFFFLL;
  }
  if ( sub_40166C("/media/SHARE/coreelec_storage/dual_boot_apt_backup.img")
    && (unsigned int)do_backup(&v8, "/media/SHARE/coreelec_storage/dual_boot_apt_backup.img", 0, 1304) )
  {
    puts("Failed to create backup of partition table file!");
  }
  if ( sub_40166C("/media/SHARE/coreelec_storage/dual_boot_dtb_backup.img")
    && (signed int)do_backup(&v7, "/media/SHARE/coreelec_storage/dual_boot_dtb_backup.img", 0, 0x80000) < 0 )
  {
    puts("Failed to create backup of bootloader dtb!");
  }
  if ( v5 )
  {
    if ( v5 == 2 )
      v11 = sub_403B48(0LL, (__int64)"/storage/backup/eMMC_backup/coreelec_storage");
  }
  else
  {
    v11 = sub_403B48(0LL, (__int64)"/storage");
  }
  if ( v8 )
  {
    if ( (signed int)sub_401B88(v8, "/media/SHARE/coreelec_storage/dual_boot_apt_backup.img", 0, 1304) < 0 )
      puts("Can not restore backup of APT!");
    free(v8);
  }
  if ( v7 )
  {
    if ( (signed int)sub_401B88(v7, "/media/SHARE/coreelec_storage/dual_boot_dtb_backup.img", 0, 0x80000) < 0 )
      puts("Can not restore backup of dtb!");
    free(v7);
  }
  if ( v11 >= 0 )
  {
LABEL_77:
    if ( (signed int)sub_403C6C() >= 0 )
    {
      puts("\nSuccess!\n");
      printf("\nPlease remove current boot media (SD or USB) and");
      puts("\nreboot the device to boot from eMMC!\n");
      qword_422238 = (__int64)"CEEMMC_RENEW";
      result = 0LL;
    }
    else
    {
      puts("Failed to umount temporary RetroLX folder");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    if ( v5 )
    {
      if ( v5 == 2 )
        printf("Failed to move data from '%s' to eMMC\n");
    }
    else
    {
      printf("Failed to move data from '%s' to eMMC\n");
    }
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 422230: using guessed type __int64 qword_422230;
// 422238: using guessed type __int64 qword_422238;

//----- (00000000004063E4) ----------------------------------------------------
signed __int64 __fastcall sub_4063E4(_QWORD *a1, unsigned int a2)
{
  signed __int64 result; // x0
  unsigned int v3; // [xsp+14h] [xbp+14h]
  __int64 v4; // [xsp+18h] [xbp+18h]
  unsigned __int64 v5; // [xsp+28h] [xbp+28h]
  unsigned __int64 v6; // [xsp+30h] [xbp+30h]
  unsigned __int64 v7; // [xsp+38h] [xbp+38h]
  unsigned __int64 v8; // [xsp+40h] [xbp+40h]
  char v9; // [xsp+48h] [xbp+48h]
  unsigned __int64 v10; // [xsp+560h] [xbp+560h]
  int v11; // [xsp+56Ch] [xbp+56Ch]

  v4 = (__int64)a1;
  v3 = a2;
  if ( (signed int)create_new_partition_table(0, a1, (int *)&v9, &v8, (__int64 *)&v7) < 0 )
  {
    puts("Failed to create new partition table!");
    return 0xFFFFFFFFLL;
  }
  if ( v3 == 1 )
  {
    if ( (signed int)sub_403418(v4, "RETROLX", "/media/RETROLX") < 0 )
    {
      printf("Failed to mount '%s' partition!\n");
      return 0xFFFFFFFFLL;
    }
    if ( (signed int)sub_403418(v4, "SHARE", "/media/SHARE") < 0 )
    {
      printf("Failed to mount '%s' partition!\n");
      return 0xFFFFFFFFLL;
    }
    putchar(10);
    if ( (signed int)sub_403F5C((__int64)"flash partiton on eMMC", "/media/RETROLX", (__int64 *)&v6) < 0 )
    {
      printf("Failed to get used space of path '%s'!\n");
      return 0xFFFFFFFFLL;
    }
    if ( (signed int)sub_403F5C((__int64)"storage partiton on eMMC", "/media/SHARE/coreelec_storage", (__int64 *)&v5) < 0 )
    {
      printf("Failed to get used space of path '%s'!\n");
      return 0xFFFFFFFFLL;
    }
    v10 = sub_403F18((__int64)"SD or USB device", "/storage");
    if ( v10 <= v6 + v5 )
    {
      puts("Not enough free space on SD or USB device to make a backup of the data on eMMC!");
      return 0xFFFFFFFFLL;
    }
    printf("\nThere is enough free space on SD or USB device to make a backup of the data from eMMC.\nContinue? [y]: ");
    if ( (unsigned __int8)sub_4015DC() != 121 )
    {
      puts("\nAborting!\n");
      return 0LL;
    }
    if ( sub_40166C("/media/SHARE/coreelec_storage/dual_boot_apt_backup.img")
      && (signed int)remove("/media/SHARE/coreelec_storage/dual_boot_apt_backup.img") < 0 )
    {
      printf("Can not remove backup of APT: %s!\n");
    }
    if ( sub_40166C("/media/SHARE/coreelec_storage/dual_boot_dtb_backup.img")
      && (signed int)remove("/media/SHARE/coreelec_storage/dual_boot_dtb_backup.img") < 0 )
    {
      printf("Can not remove backup of dtb: %s!\n");
    }
    putchar(10);
    puts("Starting to make a backup of existing data of the eMMC!");
    puts("Please do \x1B[1mNOT\x1B[0m interrupt this progress till it's finished!\n");
    if ( (signed int)sub_403888((__int64)"/media/RETROLX", "/storage/backup/eMMC_backup/coreelec_flash") < 0 )
    {
      printf("Failed to create a backup of folder '%s' on eMMC to SD or USB device!\n");
      return 0xFFFFFFFFLL;
    }
    if ( (signed int)sub_403888(
                       (__int64)"/media/SHARE/coreelec_storage",
                       "/storage/backup/eMMC_backup/coreelec_storage") < 0 )
    {
      printf("Failed to create a backup of folder '%s' on eMMC to SD or USB device!\n");
      return 0xFFFFFFFFLL;
    }
    if ( sub_40166C("/storage/backup/eMMC_backup/coreelec_storage/dual_boot_apt_backup.img")
      && (signed int)remove("/storage/backup/eMMC_backup/coreelec_storage/dual_boot_apt_backup.img") < 0 )
    {
      printf("Can not remove backup of APT: %s!\n");
    }
    if ( sub_40166C("/storage/backup/eMMC_backup/coreelec_storage/dual_boot_dtb_backup.img")
      && (signed int)remove("/storage/backup/eMMC_backup/coreelec_storage/dual_boot_dtb_backup.img") < 0 )
    {
      printf("Can not remove backup of dtb: %s!\n");
    }
  }
  else if ( v3 )
  {
    if ( v3 == 2 )
    {
      putchar(10);
      if ( (signed int)sub_403F5C(
                         (__int64)"/storage/backup/eMMC_backup/coreelec_flash",
                         "/storage/backup/eMMC_backup/coreelec_flash",
                         (__int64 *)&v6) < 0 )
      {
        printf("Failed to get used space of path '%s'!\n");
        return 0xFFFFFFFFLL;
      }
      if ( (signed int)sub_403F5C(
                         (__int64)"/storage/backup/eMMC_backup/coreelec_storage",
                         "/storage/backup/eMMC_backup/coreelec_storage",
                         (__int64 *)&v5) < 0 )
      {
        printf("Failed to get used space of path '%s'!\n");
        return 0xFFFFFFFFLL;
      }
      if ( v8 < v6 )
      {
        printf("New partition is too small to cover data of '%s' from current boot device!\n");
        printf("Free space on '%s' partition: %lldMB\n");
        printf("Used space on '%s': %lld\n");
        return 0xFFFFFFFFLL;
      }
      if ( v7 < v5 )
      {
        printf("New partition is too small to cover data of '%s' from current boot device!\n");
        printf("Free space on '%s' partition: %lldMB\n");
        printf("Used space on '%s': %lld\n");
        return 0xFFFFFFFFLL;
      }
      printf("\nThere is enough free space on eMMC for installation!\nContinue? [y]: ");
      if ( (unsigned __int8)sub_4015DC() != 121 )
      {
        puts("\nAborting!\n");
        return 0LL;
      }
    }
  }
  else
  {
    putchar(10);
    if ( (signed int)sub_403F5C((__int64)"/flash", "/flash", (__int64 *)&v6) < 0 )
    {
      printf("Failed to get used space of path '%s'!\n");
      return 0xFFFFFFFFLL;
    }
    if ( (signed int)sub_403F5C((__int64)"/storage", "/storage", (__int64 *)&v5) < 0 )
    {
      printf("Failed to get used space of path '%s'!\n");
      return 0xFFFFFFFFLL;
    }
    if ( v8 < v6 )
    {
      printf("New partition is too small to cover data of '%s' from current boot device!\n");
      printf("Free space on '%s' partition: %lldMB\n");
      printf("Used space on '%s': %lld\n");
      return 0xFFFFFFFFLL;
    }
    if ( v7 < v5 )
    {
      printf("New partition is too small to cover data of '%s' from current boot device!\n");
      printf("Free space on '%s' partition: %lldMB\n");
      printf("Used space on '%s': %lld\n");
      return 0xFFFFFFFFLL;
    }
    printf("\nThere is enough free space on eMMC for installation!\nContinue? [y]: ");
    if ( (unsigned __int8)sub_4015DC() != 121 )
    {
      puts("\nAborting!\n");
      return 0LL;
    }
  }
  if ( (unsigned int)sub_4029B4(&v9, "/dev/reserved") )
  {
    puts("Failed to write the new partition table to eMMC!");
    return 0xFFFFFFFFLL;
  }
  if ( (signed int)sub_402468(v4, (__int64)&v9) < 0 )
  {
    puts("Failed to move partitions");
    return 0xFFFFFFFFLL;
  }
  if ( (signed int)sub_402EC0((__int64)&v9, "SHARE") < 0 )
  {
    printf("Failed to format partition '%s'!\n");
    return 0xFFFFFFFFLL;
  }
  if ( (signed int)sub_403044((__int64)&v9, "RETROLX") < 0 )
  {
    printf("Failed to format partition '%s'!\n");
    return 0xFFFFFFFFLL;
  }
  if ( (signed int)sub_403418((__int64)&v9, "RETROLX", "/media/RETROLX") < 0 )
  {
    printf("Failed to mount '%s' partition!\n");
    return 0xFFFFFFFFLL;
  }
  if ( (signed int)sub_403418((__int64)&v9, "SHARE", "/media/SHARE") < 0 )
  {
    printf("Failed to mount '%s' partition!\n");
    return 0xFFFFFFFFLL;
  }
  if ( v3 )
  {
    if ( v3 <= 2 )
      v11 = sub_403B48(
              (__int64)"/storage/backup/eMMC_backup/coreelec_flash",
              (__int64)"/storage/backup/eMMC_backup/coreelec_storage");
  }
  else
  {
    puts("Stopping Kodi before start of copy process!");
    if ( (signed int)run_command("systemctl stop kodi", 0LL, 0LL) < 0 )
    {
      printf("Error executing cmd '%s'\n");
      return 0xFFFFFFFFLL;
    }
    v11 = sub_403B48((__int64)"/flash", (__int64)"/storage");
    puts("Start Kodi again to have a user interface!");
    if ( (signed int)run_command("systemctl start kodi", 0LL, 0LL) < 0 )
    {
      printf("Error executing cmd '%s'\n");
      return 0xFFFFFFFFLL;
    }
  }
  if ( v11 >= 0 )
  {
    if ( (signed int)sub_403C6C() >= 0 )
    {
      if ( v3 != 1 || (signed int)sub_4036D8("/storage/backup/eMMC_backup") >= 0 )
      {
        puts("\nSuccess!\n");
        printf("\nPlease remove current boot media (SD or USB) and");
        puts("\nreboot the device to boot from eMMC!\n");
        qword_422238 = (__int64)"CEEMMC_MIGRATE";
        result = 0LL;
      }
      else
      {
        printf("Failed to remove folder '%s'\n");
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      puts("Failed to umount temporary RetroLX folder");
      result = 0xFFFFFFFFLL;
    }
  }
  else
  {
    puts("Failed to move data from original media to eMMC");
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 422230: using guessed type __int64 qword_422230;
// 422238: using guessed type __int64 qword_422238;

//----- (0000000000406D8C) ----------------------------------------------------
signed __int64 __fastcall sub_406D8C(__int64 a1)
{
  signed __int64 result; // x0
  __int64 v2; // [xsp+18h] [xbp+18h]
  unsigned __int64 v3; // [xsp+20h] [xbp+20h]
  unsigned __int64 v4; // [xsp+28h] [xbp+28h]

  v2 = a1;
  if ( (signed int)sub_403418(a1, "RETROLX", "/media/RETROLX") < 0 )
  {
    printf("Failed to mount '%s' partition!\n");
    return 0xFFFFFFFFLL;
  }
  putchar(10);
  if ( (signed int)sub_403F5C((__int64)"flash partiton on eMMC", "/media/RETROLX", (__int64 *)&v3) < 0 )
  {
    printf("Failed to get used space of path '%s'!\n");
    return 0xFFFFFFFFLL;
  }
  v4 = sub_403F18((__int64)"SD or USB device", "/storage");
  if ( v4 <= v3 )
  {
    puts("Not enough free space on SD or USB device to make a backup of the data on eMMC!");
    return 0xFFFFFFFFLL;
  }
  printf("\nMake a backup of RetroLX data on the flash partition of eMMC?");
  if ( stat("/storage/backup/eMMC_backup/coreelec_flash") )
    printf("\nAll existing data in folder '%s' will be removed!");
  printf("\nMake backup? [y]: ");
  if ( (unsigned __int8)sub_4015DC() == 121 )
  {
    if ( (signed int)sub_4036D8("/storage/backup/eMMC_backup/coreelec_flash") < 0 )
    {
      printf("Failed to remove folder '%s'\n");
      return 0xFFFFFFFFLL;
    }
    putchar(10);
    puts("Starting to make a backup of existing data of the eMMC!");
    puts("Please do \x1B[1mNOT\x1B[0m interrupt this progress till it's finished!\n");
    if ( (signed int)sub_403888((__int64)"/media/RETROLX", "/storage/backup/eMMC_backup/coreelec_flash") < 0 )
    {
      printf("Failed to create a backup of folder '%s' on eMMC to SD or USB device!\n");
      return 0xFFFFFFFFLL;
    }
    printf("\nBackup of partition '%s' got saved at '%s'\n\n");
  }
  if ( (signed int)sub_403418(v2, "SHARE", "/media/SHARE") < 0 )
  {
    printf("Failed to mount '%s' partition!\n");
    return 0xFFFFFFFFLL;
  }
  putchar(10);
  if ( (signed int)sub_403F5C((__int64)"storage partiton on eMMC", "/media/SHARE/coreelec_storage", (__int64 *)&v3) < 0 )
  {
    printf("Failed to get used space of path '%s'!\n");
    return 0xFFFFFFFFLL;
  }
  v4 = sub_403F18((__int64)"SD or USB device", "/storage");
  if ( v4 <= v3 )
  {
    puts("Not enough free space on SD or USB device to make a backup of the data on eMMC!");
    return 0xFFFFFFFFLL;
  }
  printf("\nMake a backup of RetroLX data on the storage partition of eMMC?");
  if ( stat("/storage/backup/eMMC_backup/coreelec_storage") )
    printf("\nAll existing data in folder '%s' will be removed!");
  printf("\nMake backup? [y]: ");
  if ( (unsigned __int8)sub_4015DC() == 121 )
  {
    if ( (signed int)sub_4036D8("/storage/backup/eMMC_backup/coreelec_storage") < 0 )
    {
      printf("Failed to remove folder '%s'\n");
      return 0xFFFFFFFFLL;
    }
    putchar(10);
    puts("Starting to make a backup of existing data of the eMMC!");
    puts("Please do \x1B[1mNOT\x1B[0m interrupt this progress till it's finished!\n");
    if ( (signed int)sub_403888(
                       (__int64)"/media/SHARE/coreelec_storage",
                       "/storage/backup/eMMC_backup/coreelec_storage") < 0 )
    {
      printf("Failed to create a backup of folder '%s' on eMMC to SD or USB device!\n");
      return 0xFFFFFFFFLL;
    }
    if ( sub_40166C("/storage/backup/eMMC_backup/coreelec_storage/dual_boot_apt_backup.img")
      && (signed int)remove("/storage/backup/eMMC_backup/coreelec_storage/dual_boot_apt_backup.img") < 0 )
    {
      printf("Can not remove backup of APT: %s!\n");
    }
    if ( sub_40166C("/storage/backup/eMMC_backup/coreelec_storage/dual_boot_dtb_backup.img")
      && (signed int)remove("/storage/backup/eMMC_backup/coreelec_storage/dual_boot_dtb_backup.img") < 0 )
    {
      printf("Can not remove backup of dtb: %s!\n");
    }
    printf("\nBackup of partition '%s' got saved at '%s'\n\n");
  }
  if ( (signed int)sub_403C6C() >= 0 )
  {
    puts("\nSuccess!\n");
    puts("\nA backup of the selected RetroLX partitions where done!\n");
    qword_422238 = (__int64)"CEEMMC_BACKUP";
    result = 0LL;
  }
  else
  {
    puts("Failed to umount temporary RetroLX folder");
    result = 0xFFFFFFFFLL;
  }
  return result;
}
// 422238: using guessed type __int64 qword_422238;

//----- (00000000004071D8) ----------------------------------------------------
signed __int64 sub_4071D8()
{
  signed __int64 v1; // x0
  char v2; // [xsp+18h] [xbp-2C58h]
  char v3; // [xsp+218h] [xbp-2A58h]
  unsigned __int64 v4; // [xsp+418h] [xbp-2858h]
  char v5; // [xsp+420h] [xbp-2850h]
  __int64 v6; // [xsp+2C20h] [xbp-50h]
  __int64 v7; // [xsp+2C28h] [xbp-48h]
  __int64 v8; // [xsp+2C30h] [xbp-40h]
  unsigned __int64 v9; // [xsp+2C38h] [xbp-38h]
  DIR *v10; // [xsp+2C40h] [xbp-30h]
  int v11; // [xsp+2C48h] [xbp-28h]
  char v12; // [xsp+2C4Fh] [xbp-21h]
  char *i; // [xsp+2C50h] [xbp-20h]
  struct dirent *v14; // [xsp+2C58h] [xbp-18h]
  const char *v15; // [xsp+2C60h] [xbp-10h]
  int v16; // [xsp+2C6Ch] [xbp-4h]

  v16 = 0;
  memset(&v5, 0, 0x2800uLL);
  i = 0LL;
  v12 = 1;
  v10 = opendir("/sys/block");
  if ( !v10 )
  {
    puts("Failed to open folder '/media'");
    return 0xFFFFFFFFLL;
  }
  puts("\nSearching external SD or USB device...");
  v14 = readdir(v10);
  while ( v14 )
  {
    if ( !v14 || (unsigned int)strcmp(v14->d_name, ".") && (unsigned int)strcmp(v14->d_name, "..") )
    {
      if ( !(unsigned int)strcmp(v14->d_name, "mmcblk1") || strstr(v14->d_name, "sd") )
      {
        ++v16;
        v15 = v14->d_name;
        printf("Found external SD or USB device: %s\n");
        snprintf((char *)qword_422230, 0x2800uLL, "blkid /dev/%s*");
        if ( (signed int)run_command((const char *)qword_422230, &v5, 0LL) < 0 )
        {
          printf("Error executing cmd '%s'\n");
          return 0xFFFFFFFFLL;
        }
        for ( i = strtok(&v5, "\n"); i; i = strtok(0LL, "\n") )
          printf("\t%s\n");
      }
      v14 = readdir(v10);
    }
    else
    {
      v14 = readdir(v10);
    }
  }
  if ( !v16 )
  {
    puts("\nNo external SD or USB device is found!");
    return 0xFFFFFFFFLL;
  }
  if ( v16 > 1 )
  {
    puts("\nMore then one external SD or USB device is found!");
    return 0xFFFFFFFFLL;
  }
  v9 = sub_403E18();
  sub_4015A4((unsigned __int64)((v9 >> 9) * (unsigned __int128)0x44B82FA09B5A53uLL >> 64) >> 11);
  printf("\nExternal SD or USB device size: 0x%012llx [%dGB]\n\n");
  if ( (signed int)sub_403F5C((__int64)"/flash", "/flash", (__int64 *)&v4) < 0 )
  {
    printf("Failed to get used space of path '%s'!\n");
    return 0xFFFFFFFFLL;
  }
  if ( (signed int)sub_403F5C((__int64)"/storage", "/storage", (__int64 *)&v4) < 0 )
  {
    printf("Failed to get used space of path '%s'!\n");
    return 0xFFFFFFFFLL;
  }
  v1 = v4;
  if ( v4 < 0x2000000 )
    v1 = 0x2000000LL;
  v4 = v1;
  if ( v9 < v1 + 2151677952LL )
  {
    printf("External SD or USB device is too small to cover data of '%s' + '%s' from current RetroLX eMMC installation!\n");
    printf("Free space on '%s' external SD or USB device: %lldMB\n");
    printf("Used space on '%s' + '%s': %lld\n");
    return 0xFFFFFFFFLL;
  }
  if ( !(unsigned int)sub_4031D4("/media/COREELEC") || !(unsigned int)sub_4031D4("/media/STORAGE") )
  {
    v12 = 0;
    printf("\nWarning!\nALL existing data on external SD or USB device will be lost!");
    printf("\nPress enter to abort!");
    printf("\nContinue? [y]: ");
    if ( (unsigned __int8)sub_4015DC() != 121 )
    {
      puts("\nAborting!\n");
      return 0LL;
    }
    if ( (signed int)sub_403968((__int64)v15, 1) < 0 )
    {
      printf("Error umount of the device: '%s'\n");
      return 0xFFFFFFFFLL;
    }
    v8 = 0x2000LL;
    v7 = 4202495LL;
    memset(&v2, 0, 0x200uLL);
    memset(&v3, 0, 0x200uLL);
    snprintf((char *)qword_422230, 0x2800uLL, "parted -s \"/dev/%s\" mktable msdos");
    if ( (signed int)run_command((const char *)qword_422230, 0LL, 0LL) < 0 )
    {
      printf("Error executing cmd '%s'\n");
      return 0xFFFFFFFFLL;
    }
    snprintf((char *)qword_422230, 0x2800uLL, "parted -s \"/dev/%s\" -a min unit s mkpart primary fat32 %lld %lld");
    if ( (signed int)run_command((const char *)qword_422230, 0LL, 0LL) < 0 )
    {
      printf("Error executing cmd '%s'\n");
      return 0xFFFFFFFFLL;
    }
    snprintf((char *)qword_422230, 0x2800uLL, "parted -s \"/dev/%s\" set 1 boot on");
    if ( (signed int)run_command((const char *)qword_422230, 0LL, 0LL) < 0 )
    {
      printf("Error executing cmd '%s'\n");
      return 0xFFFFFFFFLL;
    }
    if ( strstr(v15, "mmcblk") )
    {
      snprintf(&v2, 0x200uLL, "%sp1");
      snprintf(&v3, 0x200uLL, "%sp2");
    }
    else
    {
      snprintf(&v2, 0x200uLL, "%s1");
      snprintf(&v3, 0x200uLL, "%s2");
    }
    snprintf((char *)qword_422230, 0x2800uLL, "/dev/%s");
    if ( (signed int)format_vfat_partition() < 0 )
    {
      printf("Failed to format vfat '%s' partition!\n");
      return 0xFFFFFFFFLL;
    }
    v6 = v7 + 1;
    snprintf((char *)qword_422230, 0x2800uLL, "parted -s \"/dev/%s\" -a min unit s mkpart primary ext4 %lld 100%%");
    if ( (signed int)run_command((const char *)qword_422230, 0LL, 0LL) < 0 )
    {
      printf("Error executing cmd '%s'\n");
      return 0xFFFFFFFFLL;
    }
    snprintf((char *)qword_422230, 0x2800uLL, "partprobe \"/dev/%s\"");
    if ( (signed int)run_command((const char *)qword_422230, 0LL, 0LL) < 0 )
    {
      printf("Error executing cmd '%s'\n");
      return 0xFFFFFFFFLL;
    }
    snprintf((char *)qword_422230, 0x2800uLL, "/dev/%s");
    if ( (signed int)sub_402DB0(
                       (__int64)"STORAGE",
                       qword_422230,
                       (__int64)"none,has_journal,ext_attr,resize_inode,dir_index,filetype,extent,flex_bg,sparse_super,la"
                                "rge_file,huge_file,dir_nlink,extra_isize",
                       0LL,
                       0LL) < 0 )
    {
      printf("Failed to format ext4 '%s' partition!\n");
      return 0xFFFFFFFFLL;
    }
    snprintf((char *)qword_422230, 0x2800uLL, "systemctl restart udevil-mount@/dev/%s.service 2>&1");
    if ( (signed int)run_command((const char *)qword_422230, 0LL, 0LL) < 0 )
    {
      printf("Error executing cmd '%s'\n");
      return 0xFFFFFFFFLL;
    }
    v11 = 100;
    while ( v11 )
    {
      --v11;
      if ( (unsigned int)sub_4031D4("/media/COREELEC") == 1 )
        break;
      usleep(0xC350u);
    }
    if ( !v11 )
    {
      printf("Timeout waiting for mount of '%s'!\n");
      return 0xFFFFFFFFLL;
    }
    snprintf((char *)qword_422230, 0x2800uLL, "systemctl restart udevil-mount@/dev/%s.service 2>&1");
    if ( (signed int)run_command((const char *)qword_422230, 0LL, 0LL) < 0 )
    {
      printf("Error executing cmd '%s'\n");
      return 0xFFFFFFFFLL;
    }
    v11 = 100;
    while ( v11 )
    {
      --v11;
      if ( (unsigned int)sub_4031D4("/media/STORAGE") == 1 )
        break;
      usleep(0xC350u);
    }
    if ( !v11 )
    {
      printf("Timeout waiting for mount of '%s'!\n");
      return 0xFFFFFFFFLL;
    }
  }
  if ( v12 )
  {
    printf("\nWarning!\nALL existing RetroLX data on flash partition on external SD or USB device will be lost!");
    printf("\nContinue with [y] or press enter to skip flash partition!");
    printf("\nContinue? [y]: ");
    if ( (unsigned __int8)sub_4015DC() != 121 )
      goto LABEL_74;
    if ( (signed int)sub_403624("/media/COREELEC") < 0 )
    {
      printf("Failed to remove content of folder '%s'\n");
      return 0xFFFFFFFFLL;
    }
  }
  puts("Starting copying of data from eMMC!");
  puts("Please do \x1B[1mNOT\x1B[0m interrupt this progress till it's finished!\n");
  if ( (signed int)sub_403788() < 0 )
  {
    printf("Failed to copy data from '%s' to '%s'\n");
    return 0xFFFFFFFFLL;
  }
LABEL_74:
  if ( v12 )
  {
    printf("\nWarning!\nALL existing RetroLX data on storage partition on external SD or USB device will be lost!");
    printf("\nContinue with [y] or press enter to skip storage partition!");
    printf("\nContinue? [y]: ");
    if ( (unsigned __int8)sub_4015DC() != 121 )
      goto LABEL_84;
    if ( (signed int)sub_403624("/media/STORAGE") < 0 )
    {
      printf("Failed to remove content of folder '%s'\n");
      return 0xFFFFFFFFLL;
    }
  }
  

  putchar(10);
  puts("Starting copying of data from eMMC!");
  puts("Please do \x1B[1mNOT\x1B[0m interrupt this progress till it's finished!\n");
  if ( (signed int)sub_403788() < 0 )
  {
    printf("Failed to copy data from '%s' to '%s'\n");
    return 0xFFFFFFFFLL;
  }

LABEL_84:
  puts("\nSuccess!\n");
  puts("\nYou can now reboot the device to use your boot media (SD or USB)!\n");
  qword_422238 = (__int64)"CEEMMC_BACKUP";
  return 0LL;
}
// 422230: using guessed type __int64 qword_422230;
// 422238: using guessed type __int64 qword_422238;

//----- (0000000000409320) ----------------------------------------------------
signed __int64 __fastcall sub_409320(__int64 a1, int a2, __int64 a3, _QWORD *a4, int a5, int a6)
{
  signed __int64 result; // x0
  int v7; // ST50_4
  int v8; // ST50_4
  int v9; // [xsp+1Ch] [xbp+1Ch]
  _QWORD *v10; // [xsp+20h] [xbp+20h]
  int v11; // [xsp+30h] [xbp+30h]
  int v12; // [xsp+34h] [xbp+34h]
  int v13; // [xsp+BCh] [xbp+BCh]

  v12 = a2;
  v10 = a4;
  v11 = a5;
  v9 = a6;
  if ( (unsigned int)inflateInit2_() )
  {
    printf("Error: inflateInit2() returned %d\n");
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v7 = *v10 - v9;
    do
    {
      v13 = inflate();
      if ( v11 == 1 && v13 != 1 && (!v12 || v13 != -5) )
      {
        printf("Error: inflate() returned %d\n");
        inflateEnd();
        return 0xFFFFFFFFLL;
      }
      v8 = *v10 - v9;
    }
    while ( v13 == -5 );
    *v10 = 0LL;
    inflateEnd();
    result = 0LL;
  }
  return result;
}

//----- (0000000000409494) ----------------------------------------------------
signed __int64 __fastcall sub_409494(__int64 a1, signed __int64 *a2, __int64 a3, unsigned __int64 a4, int a5, __int64 (__fastcall *a6)(__int64, signed __int64))
{
  signed __int64 result; // x0
  signed __int64 v7; // x0
  signed __int64 v8; // x0
  __int64 (__fastcall *v9)(__int64, signed __int64); // [xsp+10h] [xbp+10h]
  int v10; // [xsp+1Ch] [xbp+1Ch]
  unsigned __int64 v11; // [xsp+20h] [xbp+20h]
  __int64 v12; // [xsp+28h] [xbp+28h]
  signed __int64 *v13; // [xsp+30h] [xbp+30h]
  __int64 v14; // [xsp+38h] [xbp+38h]
  int v15; // [xsp+50h] [xbp+50h]
  unsigned int v16; // [xsp+68h] [xbp+68h]
  signed __int64 v17; // [xsp+B8h] [xbp+B8h]
  signed __int64 v18; // [xsp+C8h] [xbp+C8h]
  int v19; // [xsp+D4h] [xbp+D4h]
  signed int v20; // [xsp+DCh] [xbp+DCh]

  v14 = a1;
  v13 = a2;
  v12 = a3;
  v11 = a4;
  v10 = a5;
  v9 = a6;
  if ( !a4 )
    return 0LL;
  v19 = *a2;
  if ( (unsigned int)deflateInit2_() )
  {
    printf("Error: deflateInit2_() returned %d\n");
    result = 0xFFFFFFFFLL;
  }
  else
  {
    while ( v11 )
    {
      v7 = 512LL;
      if ( v11 <= 0x200 )
        v7 = v11;
      v18 = v7;
      v15 = v7;
      do
      {
        v8 = *v13;
        if ( (unsigned __int64)*v13 > 0x200 )
          v8 = 512LL;
        v17 = v8;
        v16 = v8;
        if ( (unsigned int)deflate() == -2 && v10 == 1 )
        {
          printf("Error: deflate() returned %d\n");
          v20 = -1;
          goto LABEL_26;
        }
        if ( v9 )
        {
          if ( v17 != v16 )
          {
            v20 = v9(v14, v17 - v16);
            if ( v20 < 0 )
              goto LABEL_26;
          }
        }
        else
        {
          v14 += v17 - v16;
          *v13 += v16 - v17;
        }
      }
      while ( !v16 && *v13 );
      if ( v15 )
      {
        printf("Deflate failed to consume %u bytes");
        v20 = -1;
        goto LABEL_26;
      }
      if ( !*v13 )
      {
        printf("Deflate need more space to compress left %lu bytes\n");
        v20 = -1;
        goto LABEL_26;
      }
      v11 -= v18;
      v12 += v18;
    }
    v20 = 0;
LABEL_26:
    deflateEnd();
    *v13 = v19 - *v13;
    result = (unsigned int)v20;
  }
  return result;
}

//----- (000000000040976C) ----------------------------------------------------
signed __int64 __fastcall sub_40976C(__int64 a1, signed __int64 *a2, __int64 a3, unsigned __int64 a4)
{
  return sub_409494(a1, a2, a3, a4, 1, 0LL);
}

//----- (00000000004097A8) ----------------------------------------------------
signed __int64 __fastcall sub_4097A8(__int64 a1, int a2, _BYTE *a3, _QWORD *a4)
{
  signed __int64 result; // x0
  int v5; // w0
  int v6; // w0
  __int64 v7; // [xsp+28h] [xbp+28h]
  int v8; // [xsp+3Ch] [xbp+3Ch]

  v7 = a1;
  v8 = 10;
  if ( a3[2] != 8 || a3[3] & 0xE0 )
  {
    puts("Error: Bad gzipped data\n");
    result = 0xFFFFFFFFLL;
  }
  else
  {
    if ( a3[3] & 4 )
      v8 = (unsigned __int8)a3[10] + 12 + ((unsigned __int8)a3[11] << 8);
    if ( a3[3] & 8 )
    {
      do
        v5 = v8++;
      while ( a3[v5] );
    }
    if ( a3[3] & 0x10 )
    {
      do
        v6 = v8++;
      while ( a3[v6] );
    }
    if ( a3[3] & 2 )
      v8 += 2;
    if ( (unsigned __int64)v8 < *a4 )
    {
      result = sub_409320(v7, a2, (__int64)a3, a4, 1, v8);
    }
    else
    {
      puts("Error: gunzip out of data in header\n");
      result = 0xFFFFFFFFLL;
    }
  }
  return result;
}

//----- (0000000000409920) ----------------------------------------------------
unsigned int __fastcall sub_409920(unsigned int *a1)
{
  return bswap32(*a1);
}

//----- (000000000040992C) ----------------------------------------------------
unsigned __int64 __fastcall sub_40992C(unsigned __int64 *a1)
{
  return bswap32(*a1);
}

//----- (0000000000409938) ----------------------------------------------------
signed __int64 __fastcall sub_409938(__int64 a1)
{
  unsigned int v1; // w0
  __int64 v2; // x2
  int v3; // w1
  unsigned int v4; // w0
  int v5; // w1
  __int64 v6; // x3
  __int64 v7; // x2
  signed __int64 v8; // x2
  int v9; // w4
  signed __int64 result; // x0

  v1 = sub_409920((unsigned int *)(a1 + 16));
  if ( v1 > v1 + 16 * v3 )
    return 0LL;
  v4 = sub_409920((unsigned int *)(v2 + 4));
  v8 = v7 + v6 + 16LL * v5;
  if ( (unsigned __int64)v4 - 16 < v9 )
    result = 0LL;
  else
    result = v8;
  return result;
}

//----- (00000000004099FC) ----------------------------------------------------
__int64 __fastcall sub_4099FC(__int64 a1, int a2, unsigned int *a3)
{
  __int64 v3; // x19
  __int64 v4; // x20
  unsigned int *v5; // x21
  unsigned int v6; // w0
  __int64 v7; // x19

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = sub_40BDE4(a1, a2);
  if ( v6 & 0x80000000 )
  {
    if ( v5 )
      *v5 = v6;
    v7 = 0LL;
  }
  else
  {
    v7 = v3 + v4 + sub_409920((unsigned int *)(v3 + 8));
    if ( v5 )
      *v5 = sub_409920((unsigned int *)(v7 + 4));
  }
  return v7;
}

//----- (0000000000409A64) ----------------------------------------------------
char *__fastcall sub_409A64(unsigned int *a1, unsigned int a2, signed int *a3)
{
  unsigned int v3; // w19
  unsigned int *v4; // x21
  signed int *v5; // x22
  unsigned int v6; // w20
  signed int v7; // w0
  unsigned int v8; // w20
  unsigned int v9; // w0
  size_t v10; // x2
  unsigned int v11; // w0
  unsigned int v12; // w19
  char *v13; // x21
  void *v14; // x0
  size_t v16; // x19

  v3 = a2;
  v4 = a1;
  v5 = a3;
  v6 = sub_409920(a1 + 3);
  v7 = sub_40B9E0(v4);
  if ( v7 )
    goto LABEL_20;
  v8 = v6 + v3;
  if ( sub_409920(v4 + 1) <= v8 )
    goto LABEL_23;
  v9 = sub_409920(v4);
  if ( v9 != -804389139 )
  {
    if ( v9 != 804389138 )
    {
      v7 = -13;
      goto LABEL_20;
    }
    if ( v3 & 0x80000000 && v3 >= -sub_409920(v4 + 8) )
    {
      v16 = -v3;
      if ( v10 > v16 )
        v10 = v16;
      goto LABEL_9;
    }
    goto LABEL_23;
  }
  if ( v3 & 0x80000000 )
    goto LABEL_23;
  if ( sub_409920(v4 + 5) > 0x10 )
  {
    v11 = sub_409920(v4 + 8);
    if ( v3 < v11 )
    {
      v12 = v11 - v3;
      if ( (unsigned int)v10 > v12 )
        v10 = v12;
      goto LABEL_9;
    }
LABEL_23:
    v7 = -4;
    goto LABEL_20;
  }
LABEL_9:
  v13 = (char *)v4 + v8;
  v14 = memchr(v13, 0, v10);
  if ( v14 )
  {
    if ( v5 )
      *v5 = (_DWORD)v14 - (_DWORD)v13;
    return v13;
  }
  v7 = -8;
LABEL_20:
  if ( v5 )
    *v5 = v7;
  return 0LL;
}

//----- (0000000000409C08) ----------------------------------------------------
__int64 __fastcall sub_409C08(__int64 a1)
{
  __int64 v1; // x6
  signed __int64 v2; // x0
  unsigned int v3; // w5

  v1 = a1;
  while ( 1 )
  {
    v2 = sub_409938(v1);
    if ( !v2 )
      break;
    if ( !sub_40992C((unsigned __int64 *)(v2 + 8)) )
      return v3;
  }
  return (unsigned int)-8;
}

//----- (0000000000409C4C) ----------------------------------------------------
const char *__fastcall sub_409C4C(unsigned int *a1, int a2, signed int *a3)
{
  unsigned int *v3; // x20
  __int64 v4; // x22
  signed int *v5; // x21
  unsigned int v6; // w19
  signed int v7; // w0
  const char *v8; // x19
  char *v9; // x0

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = sub_409920(a1 + 2);
  v7 = sub_40B9E0(v3);
  if ( !v7 )
  {
    v7 = sub_40BDA4((__int64)v3, v4);
    if ( !(v7 & 0x80000000) )
    {
      v8 = (char *)v3 + v4 + v6 + 4;
      if ( sub_409920(v3 + 5) > 0xF )
        goto LABEL_6;
      v9 = strrchr(v8, 47);
      if ( v9 )
      {
        v8 = v9 + 1;
LABEL_6:
        if ( v5 )
          *v5 = strlen(v8);
        return v8;
      }
      v7 = -11;
    }
  }
  if ( v5 )
    *v5 = v7;
  return 0LL;
}

//----- (0000000000409CF8) ----------------------------------------------------
__int64 __fastcall sub_409CF8(unsigned int *a1, unsigned int a2, const void *a3, int a4)
{
  unsigned int *v4; // x21
  const void *v5; // x22
  int v6; // w23
  unsigned int v7; // w19
  bool v8; // nf
  char v9; // vf
  const char *v11; // x0
  const char *v12; // x24
  int v13; // w24
  unsigned int v14; // [xsp+5Ch] [xbp+5Ch]
  int i; // [xsp+68h] [xbp+68h]
  int v16; // [xsp+6Ch] [xbp+6Ch]

  v4 = a1;
  v5 = a3;
  v6 = a4;
  v14 = a2;
  v7 = sub_40B9E0(a1);
  if ( !v7 )
  {
    v7 = v14;
    for ( i = 0; ; v7 = sub_40BE24((__int64)v4, v7, &i) )
    {
      if ( (v7 & 0x80000000) == 0 )
      {
        v9 = 0;
        v8 = i < 0;
      }
      else
      {
        v9 = 1;
        v8 = 0;
      }
      if ( v8 ^ (unsigned __int8)v9 )
        break;
      if ( i == 1 )
      {
        v11 = sub_409C4C(v4, v7, &v16);
        v12 = v11;
        if ( v11 )
        {
          if ( v6 <= v16 && !(unsigned int)memcmp(v11, v5, v6) )
          {
            v13 = (unsigned __int8)v12[v6];
            if ( !v13 || !memchr(v5, 64, v6) && v13 == 64 )
              return v7;
          }
        }
      }
    }
    if ( i < 0 )
      v7 = 1;
  }
  return v7;
}

//----- (0000000000409E2C) ----------------------------------------------------
signed __int64 __fastcall sub_409E2C(__int64 a1, int a2)
{
  __int64 v2; // x20
  unsigned int v3; // w19
  int v4; // w0
  __int64 v5; // x19
  signed __int64 result; // x0
  int v7; // [xsp+3Ch] [xbp+1Ch]

  v5 = a1;
  result = sub_40BDA4(a1, a2);
  if ( !(result & 0x80000000) )
  {
    v2 = v5;
    v3 = result;
    while ( 1 )
    {
      v4 = sub_40BC58(v2, v3, (unsigned int *)&v7);
      if ( v4 == 3 )
        break;
      v3 = v7;
      if ( v4 == 9 )
      {
        if ( v7 >= 0 )
          v3 = -11;
        break;
      }
      if ( v4 != 4 )
      {
        v3 = -1;
        break;
      }
    }
    result = v3;
  }
  return result;
}

//----- (0000000000409E64) ----------------------------------------------------
signed __int64 __fastcall sub_409E64(__int64 a1, int a2)
{
  signed __int64 result; // x0

  result = sub_40BDE4(a1, a2);
  if ( !(result & 0x80000000) )
    JUMPOUT(&loc_40998C);
  return result;
}

//----- (0000000000409E9C) ----------------------------------------------------
__int64 __fastcall sub_409E9C(__int64 a1, int a2, const void *a3, int a4, unsigned int *a5, int *a6)
{
  size_t v6; // x27
  unsigned int *v7; // x22
  unsigned int *v8; // x21
  int *v9; // x24
  int v10; // w23
  const void *v11; // x25
  int i; // w19
  __int64 v13; // x20
  __int64 v14; // x0
  unsigned int v15; // w0
  char *v16; // x0
  int v18; // [xsp+6Ch] [xbp+6Ch]

  v6 = a4;
  v7 = (unsigned int *)a1;
  v8 = a5;
  v9 = a6;
  v10 = a4;
  v11 = a3;
  for ( i = sub_409E2C(a1, a2); ; i = sub_409E64((__int64)v7, i) )
  {
    if ( i & 0x80000000 )
      goto LABEL_3;
    v14 = sub_4099FC((__int64)v7, i, v8);
    v13 = v14;
    if ( !v14 )
    {
      i = -13;
LABEL_3:
      if ( v8 )
        *v8 = i;
      return 0LL;
    }
    v15 = sub_409920((unsigned int *)(v14 + 8));
    v16 = sub_409A64(v7, v15, &v18);
    if ( v16 )
    {
      if ( v10 == v18 && !(unsigned int)memcmp(v16, v11, v6) )
        break;
    }
  }
  if ( v9 )
    *v9 = i;
  return v13;
}

//----- (000000000040A00C) ----------------------------------------------------
__int64 __fastcall sub_40A00C(__int64 a1, __int64 a2, const char *a3)
{
  int v3; // w1
  const void *v4; // x2
  int v5; // w3
  unsigned int *v6; // x4
  __int64 v7; // x6
  __int64 v9; // x19

  v9 = a1;
  strlen(a3);
  if ( sub_409920((unsigned int *)(v9 + 20)) > 0xF )
    return sub_409E9C(v7, v3, v4, v5, v6, 0LL);
  if ( v6 )
    *v6 = -10;
  return 0LL;
}

//----- (000000000040A04C) ----------------------------------------------------
__int64 __fastcall sub_40A04C(__int64 a1, int a2, const void *a3, int a4, unsigned int *a5)
{
  __int64 v5; // x19
  __int64 v6; // x1
  __int64 v7; // x1
  int v9; // [xsp+2Ch] [xbp+2Ch]

  v5 = a1;
  v6 = sub_409E9C(a1, a2, a3, a4, a5, &v9);
  if ( v6 )
  {
    if ( sub_409920((unsigned int *)(v5 + 20)) <= 0xF
      && ((_BYTE)v9 + 12) & 7
      && sub_409920((unsigned int *)(v7 + 4)) > 7 )
    {
      v6 = v7 + 16;
    }
    else
    {
      v6 = v7 + 12;
    }
  }
  return v6;
}

//----- (000000000040A0B8) ----------------------------------------------------
__int64 __fastcall sub_40A0B8(__int64 a1, int a2, char **a3, unsigned int *a4)
{
  char v4; // w20
  unsigned int *v5; // x22
  unsigned int *v6; // x21
  char **v7; // x23
  __int64 v8; // x0
  __int64 v9; // x19
  unsigned int v10; // w0
  char *v11; // x0
  unsigned int v13; // [xsp+4Ch] [xbp+4Ch]

  v4 = a2;
  v5 = (unsigned int *)a1;
  v6 = a4;
  v7 = a3;
  v8 = sub_4099FC(a1, a2, a4);
  v9 = v8;
  if ( !v8 )
    return v9;
  if ( !v7 )
    goto LABEL_9;
  v10 = sub_409920((unsigned int *)(v8 + 8));
  v11 = sub_409A64(v5, v10, (signed int *)&v13);
  if ( v11 )
  {
    *v7 = v11;
LABEL_9:
    if ( sub_409920(v5 + 5) <= 0xF && (v4 + 4) & 7 && sub_409920((unsigned int *)(v9 + 4)) > 7 )
      v9 += 16LL;
    else
      v9 += 12LL;
    return v9;
  }
  if ( v6 )
    *v6 = v13;
  return 0LL;
}

//----- (000000000040A174) ----------------------------------------------------
__int64 __fastcall sub_40A174(__int64 a1, int a2, const char *a3, unsigned int *a4)
{
  __int64 v4; // x19
  const char *v5; // ST28_8
  unsigned int *v6; // ST30_8
  int v7; // ST3C_4
  int v8; // w0

  v4 = a1;
  v5 = a3;
  v6 = a4;
  v7 = a2;
  v8 = strlen(a3);
  return sub_40A04C(v4, v7, v5, v8, v6);
}

//----- (000000000040A1B4) ----------------------------------------------------
__int64 __fastcall sub_40A1B4(__int64 a1, int a2)
{
  __int64 v2; // x20
  int v3; // w21
  unsigned int *v4; // x0
  __int64 result; // x0
  int v6; // [xsp+3Ch] [xbp+3Ch]

  v2 = a1;
  v3 = a2;
  v4 = (unsigned int *)sub_40A174(a1, a2, "phandle", (unsigned int *)&v6);
  if ( v4 && v6 == 4
    || (v4 = (unsigned int *)sub_40A174(v2, v3, (const char *)&unk_40FA89, (unsigned int *)&v6)) != 0LL && v6 == 4 )
  {
    result = sub_409920(v4);
  }
  else
  {
    result = 0LL;
  }
  return result;
}

//----- (000000000040A2B4) ----------------------------------------------------
__int64 __fastcall sub_40A2B4(__int64 a1, const void *a2, int a3)
{
  const void *v3; // x20
  __int64 v4; // x19
  int v5; // w0
  __int64 result; // x0
  int v7; // [xsp+2Ch] [xbp+2Ch]

  v3 = a2;
  v4 = a1;
  v7 = a3;
  v5 = sub_40A408((unsigned int *)a1, "/aliases");
  if ( v5 & 0x80000000 )
    result = 0LL;
  else
    result = sub_40A04C(v4, v5, v3, v7, 0LL);
  return result;
}

//----- (000000000040A408) ----------------------------------------------------
__int64 __fastcall sub_40A408(unsigned int *a1, const char *a2)
{
  const char *v2; // x19
  int v3; // w21
  unsigned int *v4; // x23
  unsigned int v5; // w20
  size_t v6; // x2
  const char *v7; // x21
  const char *v8; // x0
  const char *v9; // x22
  __int64 v10; // x0
  const char *v11; // x0
  const char *v12; // x2
  const char *v13; // x22
  int v14; // w3
  unsigned int *v16; // x19
  int v17; // w2
  unsigned int *v18; // x0
  const char *v19; // [xsp+38h] [xbp+28h]

  v16 = a1;
  v19 = a2;
  v17 = strlen(a2);
  v18 = v16;
  v2 = v19;
  v3 = v17;
  v4 = v18;
  v5 = sub_40B9E0(v18);
  if ( !v5 )
  {
    v6 = v3;
    v7 = &v19[v3];
    if ( *v19 != 47 )
    {
      v8 = (const char *)memchr(v19, 47, v6);
      if ( v8 )
        v9 = v8;
      else
        v9 = v7;
      v10 = sub_40A2B4((__int64)v4, v19, (signed int)v9 - (signed int)v19);
      if ( !v10 )
        return (unsigned int)-5;
      v2 = v9;
      v5 = sub_40A408(v4, v10);
    }
    do
    {
      if ( v2 >= v7 )
        break;
      while ( *v2 == 47 )
      {
        if ( v7 == ++v2 )
          return v5;
      }
      v11 = (const char *)memchr(v2, 47, v7 - v2);
      v12 = v2;
      v13 = v11 ? v11 : v7;
      v14 = (_DWORD)v13 - (_DWORD)v2;
      v2 = v13;
      v5 = sub_409CF8(v4, v5, v12, v14);
    }
    while ( !(v5 & 0x80000000) );
  }
  return v5;
}

//----- (000000000040A5F0) ----------------------------------------------------
signed __int64 __fastcall sub_40A5F0(unsigned int *a1, int a2, int a3, _DWORD *a4)
{
  int v4; // w20
  int v5; // w21
  _DWORD *v6; // x22
  __int64 v7; // x23
  signed __int64 result; // x0
  unsigned int v9; // w19
  bool v10; // nf
  unsigned __int8 v11; // vf
  int v12; // w1
  int i; // [xsp+4Ch] [xbp+4Ch]

  v4 = a3;
  v5 = a2;
  v6 = a4;
  v7 = (__int64)a1;
  result = sub_40B9E0(a1);
  if ( !(_DWORD)result )
  {
    if ( v4 & 0x80000000 )
    {
      result = 0xFFFFFFFFLL;
    }
    else
    {
      v9 = -13;
      for ( i = 0; ; result = sub_40BE24(v7, result, &i) )
      {
        if ( (signed int)result >= 0 )
        {
          v11 = __OFSUB__(v5, (_DWORD)result);
          v10 = v5 - (signed int)result < 0;
        }
        else
        {
          v11 = 1;
          v10 = 0;
        }
        if ( v10 ^ v11 )
          break;
        v12 = i;
        if ( v4 == i )
          v9 = result;
        if ( v5 == (_DWORD)result )
        {
          if ( v6 )
            *v6 = i;
          if ( v4 > v12 )
            result = 1LL;
          else
            result = v9;
          return result;
        }
      }
      if ( ((signed int)result + 1 < 0) ^ __OFADD__((_DWORD)result, 1) )
      {
        if ( (_DWORD)result == -4 )
          result = 4294967285LL;
      }
      else
      {
        result = 4294967292LL;
      }
    }
  }
  return result;
}

//----- (000000000040A6AC) ----------------------------------------------------
__int64 __fastcall sub_40A6AC(unsigned int *a1, int a2)
{
  signed int v2; // w0
  unsigned int v3; // w1
  __int64 result; // x0
  unsigned int v5; // [xsp+1Ch] [xbp+1Ch]

  v2 = sub_40A5F0(a1, a2, 0, &v5);
  if ( v2 >= 0 )
    v3 = -13;
  else
    v3 = v2;
  if ( v2 )
    result = v3;
  else
    result = v5;
  return result;
}

//----- (000000000040A864) ----------------------------------------------------
signed __int64 __fastcall sub_40A864(const void *a1, int a2, const char *a3)
{
  const void *v3; // x20
  int v4; // w19
  const char *v5; // x23
  int v6; // w22
  char *v8; // x0

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = strlen(a3);
  while ( 1 )
  {
    if ( v4 < v6 )
      return 0LL;
    if ( !(unsigned int)memcmp(v5, v3, v6 + 1) )
      break;
    v8 = (char *)memchr(v3, 0, v4);
    if ( !v8 )
      return 0LL;
    v4 = v4 - 1 - ((_DWORD)v8 - (_DWORD)v3);
    v3 = v8 + 1;
  }
  return 1LL;
}

//----- (000000000040AAE8) ----------------------------------------------------
__int64 __fastcall sub_40AAE8(__int64 a1, int a2, const char *a3)
{
  const char *v3; // x19
  const void *v4; // x0
  __int64 result; // x0
  unsigned int v6; // [xsp+2Ch] [xbp+2Ch]

  v3 = a3;
  v4 = (const void *)sub_40A174(a1, a2, "compatible", &v6);
  if ( v4 )
    result = (unsigned int)sub_40A864(v4, v6, v3) == 0;
  else
    result = v6;
  return result;
}

//----- (000000000040ACD4) ----------------------------------------------------
unsigned int __fastcall sub_40ACD4(unsigned int a1)
{
  return bswap32(a1);
}

//----- (000000000040ACDC) ----------------------------------------------------
unsigned __int64 __fastcall sub_40ACDC(unsigned __int64 a1)
{
  return bswap32(a1);
}

//----- (000000000040ACE4) ----------------------------------------------------
unsigned int __fastcall sub_40ACE4(unsigned int *a1)
{
  return bswap32(*a1);
}

//----- (000000000040ACF0) ----------------------------------------------------
bool __fastcall sub_40ACF0(__int64 a1)
{
  __int64 v1; // x3
  unsigned int v2; // w0
  __int64 v3; // x3
  int v4; // w1
  int v5; // w5
  unsigned int v6; // w0
  __int64 v7; // x3
  int v8; // w2
  int v9; // w4
  __int64 v10; // x3
  unsigned int v11; // w0
  int v12; // w1
  unsigned int v13; // w2

  if ( sub_40ACE4((unsigned int *)(a1 + 16)) <= 0x27 )
    return 1LL;
  v2 = sub_40ACE4((unsigned int *)(v1 + 8));
  if ( v2 < v4 + v5 )
    return 1LL;
  v6 = sub_40ACE4((unsigned int *)(v3 + 12));
  if ( v6 < v8 + v9 )
    return 1LL;
  sub_40ACE4((unsigned int *)(v7 + 4));
  v11 = sub_40ACE4((unsigned int *)(v10 + 32));
  return v13 < v12 + v11;
}

//----- (000000000040AD70) ----------------------------------------------------
signed __int64 __fastcall sub_40AD70(unsigned int *a1)
{
  __int64 v1; // x19
  signed __int64 result; // x0
  int v3; // w6

  v1 = (__int64)a1;
  result = sub_40B9E0(a1);
  if ( !(_DWORD)result )
  {
    if ( sub_40ACE4((unsigned int *)(v1 + 20)) <= 0x10 )
    {
      result = 4294967286LL;
    }
    else
    {
      sub_40ACE4((unsigned int *)(v1 + 36));
      result = sub_40ACF0(v1);
      if ( (_DWORD)result )
      {
        result = 4294967284LL;
      }
      else if ( v3 != 17 )
      {
        *(_DWORD *)(v1 + 20) = 285212672;
      }
    }
  }
  return result;
}

//----- (000000000040ADE4) ----------------------------------------------------
__int64 __fastcall sub_40ADE4(unsigned int *a1, _DWORD *a2, int a3, signed int a4)
{
  unsigned int v4; // w22
  signed int v5; // w21
  _DWORD *v6; // x20
  unsigned int *v7; // x19
  unsigned int v8; // w23
  unsigned int v9; // w0
  int v10; // w2
  unsigned int v11; // w0
  void *v12; // x3
  unsigned int v13; // w0
  const void *v14; // x1
  void *v15; // x3
  unsigned int v16; // w0
  __int64 result; // x0

  v4 = a3 + 40;
  v5 = a4;
  v6 = a2;
  v7 = a1;
  v8 = a3 + 40 + a4;
  v9 = sub_40ACE4(a1 + 4);
  memmove(v6 + 10, (char *)v7 + v9, v10);
  v6[4] = 671088640;
  v11 = sub_40ACE4(v7 + 2);
  memmove(v12, (char *)v7 + v11, v5);
  v6[2] = sub_40ACD4(v4);
  v6[9] = sub_40ACD4(v5);
  sub_40ACE4(v7 + 3);
  v7 += 8;
  v13 = sub_40ACE4(v7);
  memmove(v15, v14, v13);
  v6[3] = sub_40ACD4(v8);
  v16 = sub_40ACE4(v7);
  result = sub_40ACD4(v16);
  v6[8] = result;
  return result;
}

//----- (000000000040AEB8) ----------------------------------------------------
signed __int64 __fastcall sub_40AEB8(__int64 a1)
{
  __int64 v1; // x5
  unsigned int v2; // w0
  unsigned __int64 v3; // x1
  __int64 v4; // x2
  int v5; // w3
  unsigned __int64 v6; // x5
  int v7; // w4
  unsigned __int64 v8; // x4
  unsigned int v9; // w0
  const void *v10; // x1
  __int64 v11; // x2
  __int64 v12; // x3
  __int64 v13; // x4
  __int64 v14; // x6
  __int64 v15; // x5
  unsigned __int64 v16; // x7

  sub_40ACE4((unsigned int *)(a1 + 12));
  v2 = sub_40ACE4((unsigned int *)(v1 + 32));
  v8 = v6 + (signed int)(v7 + v2);
  if ( v4 & 0x80000000 )
    return 4294967292LL;
  v4 = (signed int)v4;
  if ( v3 + (signed int)v4 > v8 || v3 < v6 || v8 + v5 - v4 < v6 )
    return 4294967292LL;
  v9 = sub_40ACE4((unsigned int *)(v6 + 4));
  if ( v16 > v15 + (unsigned __int64)v9 )
    return 4294967293LL;
  memmove((void *)(v14 + v12), v10, v13 - v14 - v11);
  return 0LL;
}

//----- (000000000040AF54) ----------------------------------------------------
__int64 __fastcall sub_40AF54(__int64 a1, __int64 a2, int a3, int a4)
{
  __int64 v4; // x20
  int v5; // w19
  int v6; // w21
  unsigned int v7; // w1
  unsigned int v8; // w0
  int v9; // w19
  unsigned int v10; // w0

  v4 = a1;
  v5 = a4;
  v6 = a3;
  v7 = sub_40AEB8(a1);
  if ( !v7 )
  {
    v8 = sub_40ACE4((unsigned int *)(v4 + 8));
    v9 = 16 * (v5 - v6);
    *(_DWORD *)(v4 + 8) = sub_40ACD4(v9 + v8);
    v10 = sub_40ACE4((unsigned int *)(v4 + 12));
    *(_DWORD *)(v4 + 12) = sub_40ACD4(v9 + v10);
  }
  return v7;
}

//----- (000000000040AFC8) ----------------------------------------------------
__int64 __fastcall sub_40AFC8(__int64 a1, __int64 a2, int a3, int a4)
{
  __int64 v4; // x19
  int v5; // w20
  int v6; // w21
  unsigned int v7; // w1
  int v8; // w20
  unsigned int v9; // w0
  unsigned int v10; // w0

  v4 = a1;
  v5 = a4;
  v6 = a3;
  v7 = sub_40AEB8(a1);
  if ( !v7 )
  {
    v8 = v5 - v6;
    v9 = sub_40ACE4((unsigned int *)(v4 + 36));
    *(_DWORD *)(v4 + 36) = sub_40ACD4(v9 + v8);
    v10 = sub_40ACE4((unsigned int *)(v4 + 12));
    *(_DWORD *)(v4 + 12) = sub_40ACD4(v8 + v10);
  }
  return v7;
}

//----- (000000000040B030) ----------------------------------------------------
__int64 __fastcall sub_40B030(__int64 a1, int a2, const char *a3, unsigned int a4, _QWORD *a5)
{
  unsigned int *v5; // x21
  _QWORD *v6; // x24
  const char *v7; // x28
  int v8; // w0
  __int64 v9; // x19
  char *v10; // x25
  int v11; // w22
  int v12; // w0
  char *v13; // x0
  unsigned int v14; // w20
  unsigned int v15; // w0
  __int64 v16; // x1
  unsigned int v17; // w0
  __int64 v18; // x1
  __int64 v20; // x27
  int v21; // w22
  unsigned int v22; // w0
  unsigned int v23; // [xsp+6Ch] [xbp+6Ch]

  v5 = (unsigned int *)a1;
  v6 = a5;
  v7 = a3;
  v23 = a4;
  v8 = sub_40BDA4(a1, a2);
  v9 = v8;
  if ( !(v8 & 0x80000000) )
  {
    v10 = (char *)v5 + sub_40ACE4(v5 + 3);
    v11 = strlen(v7);
    v12 = sub_40ACE4(v5 + 8);
    v13 = sub_40BF7C(v10, v12, v7);
    if ( v13 )
    {
      v14 = (_DWORD)v13 - (_DWORD)v10;
    }
    else
    {
      v20 = sub_40ACE4(v5 + 8);
      v21 = v11 + 1;
      sub_40ACE4(v5 + 3);
      v14 = sub_40AEB8((__int64)v5);
      if ( !v14 )
      {
        v22 = sub_40ACE4(v5 + 8);
        v5[8] = sub_40ACD4(v21 + v22);
        v14 = v20;
        memcpy(&v10[v20], v7, v21);
      }
    }
    if ( v14 & 0x80000000 )
    {
      LODWORD(v9) = v14;
    }
    else
    {
      v9 += sub_40ACE4(v5 + 2);
      *v6 = (char *)v5 + v9;
      LODWORD(v9) = sub_40AFC8((__int64)v5, (__int64)v5 + v9, 0, ((v23 + 3) & 0xFFFFFFFC) + 12);
      if ( !(_DWORD)v9 )
      {
        *(_DWORD *)*v6 = 50331648;
        v15 = sub_40ACD4(v14);
        *(_DWORD *)(v16 + 8) = v15;
        v17 = sub_40ACD4(v23);
        *(_DWORD *)(v18 + 4) = v17;
      }
    }
  }
  return (unsigned int)v9;
}

//----- (000000000040B34C) ----------------------------------------------------
signed __int64 __fastcall sub_40B34C(unsigned int *a1, unsigned int a2, const char *a3, unsigned int a4, _QWORD *a5)
{
  __int64 v5; // x19
  unsigned int v6; // w20
  unsigned int v7; // w22
  _QWORD *v8; // x21
  const char *v9; // x23
  signed __int64 result; // x0
  __int64 v11; // x0
  unsigned int v12; // [xsp+44h] [xbp+44h]
  __int64 v13; // [xsp+48h] [xbp+48h]

  v5 = (__int64)a1;
  v6 = a4;
  v7 = a2;
  v8 = a5;
  v9 = a3;
  result = sub_40AD70(a1);
  if ( !(_DWORD)result )
  {
    v11 = sub_40A00C(v5, v7, v9);
    v13 = v11;
    if ( !v11 )
    {
      result = v12;
      if ( v12 != -1 )
        goto LABEL_4;
      goto LABEL_10;
    }
    result = sub_40AFC8(v5, v11 + 12, (v12 + 3) & 0xFFFFFFFC, (v6 + 3) & 0xFFFFFFFC);
    if ( !(_DWORD)result )
    {
      *(_DWORD *)(v13 + 4) = sub_40ACD4(v6);
LABEL_8:
      *v8 = v13 + 12;
      return 0LL;
    }
    if ( (_DWORD)result == -1 )
    {
LABEL_10:
      result = sub_40B030(v5, v7, v9, v6, &v13);
LABEL_4:
      if ( (_DWORD)result )
        return result;
      goto LABEL_8;
    }
  }
  return result;
}

//----- (000000000040B734) ----------------------------------------------------
__int64 __fastcall sub_40B734(unsigned int *a1, signed int a2)
{
  __int64 v2; // x19
  signed int v3; // w20
  unsigned int v4; // w0
  unsigned int v5; // w2
  unsigned int v6; // w0
  int v7; // w2

  v2 = (__int64)a1;
  v3 = a2;
  v4 = sub_40AD70(a1);
  if ( v4 )
  {
    v5 = v4;
  }
  else
  {
    v5 = sub_40C18C(v2, v3);
    if ( !(v5 & 0x80000000) )
    {
      v6 = sub_40ACE4((unsigned int *)(v2 + 8));
      return sub_40AFC8(v2, v2 + v3 + (unsigned __int64)v6, v7 - v3, 0);
    }
  }
  return v5;
}

//----- (000000000040B95C) ----------------------------------------------------
__int64 __fastcall sub_40B95C(unsigned int *a1)
{
  unsigned int *v1; // x19
  unsigned int v2; // w20
  signed int v3; // w0
  int v4; // w2
  unsigned int v5; // w0
  int v6; // w1

  v1 = a1;
  v2 = sub_40AD70(a1);
  if ( !v2 )
  {
    sub_409C08((__int64)v1);
    v3 = sub_40ACE4(v1 + 9);
    sub_40ADE4(v1, v1, 16 * (v4 + 1), v3);
    sub_40ACE4(v1 + 3);
    v5 = sub_40ACE4(v1 + 8);
    v1[1] = sub_40ACD4(v6 + v5);
  }
  return v2;
}

//----- (000000000040B9D4) ----------------------------------------------------
unsigned int __fastcall sub_40B9D4(unsigned int *a1)
{
  return bswap32(*a1);
}

//----- (000000000040B9E0) ----------------------------------------------------
signed __int64 __fastcall sub_40B9E0(unsigned int *a1)
{
  unsigned int v1; // w0
  __int64 v2; // x1
  __int64 v3; // x1
  signed __int64 result; // x0

  v1 = sub_40B9D4(a1);
  if ( v1 == -804389139 )
  {
    if ( sub_40B9D4((unsigned int *)(v2 + 20)) <= 1 )
    {
      result = 4294967286LL;
    }
    else if ( sub_40B9D4((unsigned int *)(v3 + 24)) > 0x11 )
    {
      result = 4294967286LL;
    }
    else
    {
      result = 0LL;
    }
  }
  else if ( v1 == 804389138 )
  {
    if ( sub_40B9D4((unsigned int *)(v2 + 36)) )
      result = 0LL;
    else
      result = 4294967289LL;
  }
  else
  {
    result = 4294967287LL;
  }
  return result;
}

//----- (000000000040BA64) ----------------------------------------------------
signed __int64 __fastcall sub_40BA64(unsigned int a1)
{
  bool v1; // cf
  signed __int64 result; // x0

  if ( a1 <= 1 )
    return 28LL;
  if ( a1 == 2 )
    return 32LL;
  v1 = a1 >= 0x11;
  result = 36LL;
  if ( v1 )
    result = 40LL;
  return result;
}

//----- (000000000040BA98) ----------------------------------------------------
signed __int64 __fastcall sub_40BA98(unsigned int *a1)
{
  unsigned int *v1; // x19
  unsigned int v2; // w0
  unsigned int v3; // w0
  unsigned int v4; // w4
  unsigned int v5; // w0
  unsigned __int64 v6; // x3
  unsigned int v7; // w0
  unsigned int v8; // w3
  unsigned int v9; // w1
  bool v10; // cf
  bool v11; // zf
  unsigned int v12; // w0
  int v13; // w2
  unsigned int v14; // w1
  unsigned int v15; // w3
  _BOOL4 v16; // w0
  unsigned int v17; // w4
  signed __int64 result; // x0
  unsigned int v19; // w0
  unsigned int v20; // w1
  unsigned int v21; // w2
  unsigned int v22; // w0
  unsigned int v23; // w1
  int v24; // w2
  unsigned int v25; // w3
  bool v26; // cf
  unsigned int v27; // w0
  unsigned int v28; // w1
  unsigned int v29; // w2

  v1 = a1;
  if ( sub_40B9D4(a1) != -804389139 )
    return 4294967287LL;
  v2 = sub_40B9D4(v1 + 5);
  sub_40BA64(v2);
  if ( sub_40B9D4(v1 + 5) <= 1 )
    return 4294967286LL;
  v3 = sub_40B9D4(v1 + 6);
  if ( v3 > 0x11 || v4 < v3 )
    return 4294967286LL;
  v5 = sub_40B9D4(v1 + 1);
  if ( v6 > v5 || v5 & 0x80000000 )
    return 4294967288LL;
  v7 = sub_40B9D4(v1 + 4);
  if ( v9 >= v7 )
  {
    v10 = v8 >= v7;
    v11 = v8 == v7;
  }
  else
  {
    v10 = 1;
    v11 = 0;
  }
  if ( !v11 && v10 )
    return 4294967288LL;
  v12 = sub_40B9D4(v1 + 2);
  v16 = v14 >= v12 && v15 <= v12;
  if ( v17 > 0x10 )
  {
    if ( !v16 )
      return 4294967288LL;
    v19 = sub_40B9D4(v1 + 9) + v13;
    if ( v19 < v21 || v20 < v19 )
      return 4294967288LL;
  }
  else if ( !v16 )
  {
    return 4294967288LL;
  }
  v22 = sub_40B9D4(v1 + 3);
  if ( v25 <= v22 )
    v26 = v23 >= v22;
  else
    v26 = 0;
  if ( !v26 )
    return 4294967288LL;
  v27 = v24 + sub_40B9D4(v1 + 8);
  if ( v29 > v27 )
    return 4294967288LL;
  if ( v28 >= v27 )
    result = 0LL;
  else
    result = 4294967288LL;
  return result;
}

//----- (000000000040BBD0) ----------------------------------------------------
unsigned __int64 __fastcall sub_40BBD0(__int64 a1, int a2)
{
  unsigned int v2; // w0
  int v3; // w2
  __int64 v4; // x3
  unsigned int v5; // w5
  unsigned int v6; // w1
  __int64 v7; // x3
  unsigned int v8; // w1
  unsigned int v9; // w2
  __int64 v10; // x3
  unsigned int v11; // w4
  unsigned __int64 result; // x0

  v2 = sub_40B9D4((unsigned int *)(a1 + 8)) + a2;
  if ( v6 > v2
    || v2 + v3 < v2
    || v5 > sub_40B9D4((unsigned int *)(v4 + 4))
    || sub_40B9D4((unsigned int *)(v7 + 20)) > 0x10 && (v8 > v8 + v9 || v9 > sub_40B9D4((unsigned int *)(v10 + 36))) )
  {
    result = 0LL;
  }
  else
  {
    result = v10 + (signed int)v8 + (unsigned __int64)v11;
  }
  return result;
}

//----- (000000000040BC58) ----------------------------------------------------
__int64 __fastcall sub_40BC58(__int64 a1, int a2, unsigned int *a3)
{
  unsigned int *v3; // x21
  __int64 v4; // x22
  int v5; // w23
  _DWORD *v6; // x0
  unsigned int v7; // w20
  int v8; // w19
  _BYTE *v9; // x0
  _DWORD *v11; // x0
  unsigned int v12; // w1
  char v13; // w2

  v3 = a3;
  v4 = a1;
  v5 = a2;
  *a3 = -8;
  v6 = (_DWORD *)sub_40BBD0(a1, a2);
  if ( v6 )
  {
    v8 = v5 + 4;
    v7 = ((unsigned __int8)(*v6 >> 16) << 8) | ((unsigned __int16)*v6 >> 8 << 16) | (*v6 >> 24) | (*v6 << 24);
    *v3 = -11;
    switch ( v7 )
    {
      case 1u:
        break;
      case 2u:
      case 4u:
      case 9u:
        goto LABEL_6;
      case 3u:
        v11 = (_DWORD *)sub_40BBD0(v4, v8);
        if ( !v11 )
          return 9;
        v8 = (((unsigned __int8)(*v11 >> 16) << 8) | ((unsigned __int16)*v11 >> 8 << 16) | (*v11 >> 24) | (*v11 << 24))
           + v5
           + 12;
        if ( sub_40B9D4((unsigned int *)(v4 + 20)) <= 0xF && v12 > 7 && v13 & 7 )
          v8 += 4;
        goto LABEL_6;
      default:
        return 9;
    }
    while ( 1 )
    {
      v9 = (_BYTE *)sub_40BBD0(v4, v8);
      if ( !v9 )
        break;
      ++v8;
      if ( !*v9 )
      {
LABEL_6:
        if ( !sub_40BBD0(v4, v5) )
          return 9;
        *v3 = (v8 + 3) & 0xFFFFFFFC;
        return v7;
      }
    }
  }
  return 9;
}

//----- (000000000040BDA4) ----------------------------------------------------
signed __int64 __fastcall sub_40BDA4(__int64 a1, int a2)
{
  signed __int64 result; // x0
  unsigned int v3; // [xsp+1Ch] [xbp+1Ch]

  v3 = a2;
  if ( a2 & 0x80000000 || a2 & 3 || (unsigned int)sub_40BC58(a1, a2, &v3) != 1 )
    result = 4294967292LL;
  else
    result = v3;
  return result;
}

//----- (000000000040BDE4) ----------------------------------------------------
signed __int64 __fastcall sub_40BDE4(__int64 a1, int a2)
{
  signed __int64 result; // x0
  unsigned int v3; // [xsp+1Ch] [xbp+1Ch]

  v3 = a2;
  if ( a2 & 0x80000000 || a2 & 3 || (unsigned int)sub_40BC58(a1, a2, &v3) != 3 )
    result = 4294967292LL;
  else
    result = v3;
  return result;
}

//----- (000000000040BE24) ----------------------------------------------------
__int64 __fastcall sub_40BE24(__int64 a1, int a2, int *a3)
{
  int *v3; // x20
  __int64 v4; // x21
  unsigned int v5; // w19
  int v6; // w0
  int v8; // w0
  unsigned int v9; // [xsp+3Ch] [xbp+3Ch]

  v3 = a3;
  v4 = a1;
  v9 = 0;
  if ( a2 & 0x80000000 || (v9 = sub_40BDA4(a1, a2), v5 = v9, !(v9 & 0x80000000)) )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v5 = v9;
        v6 = sub_40BC58(v4, v9, &v9);
        if ( v6 != 2 )
          break;
        if ( v3 )
        {
          v8 = *v3 - 1;
          *v3 = v8;
          if ( v8 & 0x80000000 )
            return v9;
        }
      }
      if ( v6 == 9 )
        break;
      if ( v6 == 1 )
      {
        if ( v3 )
          ++*v3;
        return v5;
      }
    }
    v5 = v9;
    if ( v9 & 0x80000000 )
    {
      if ( v9 == -8 && !v3 )
        v5 = 1;
    }
    else
    {
      v5 = -1;
    }
  }
  return v5;
}

//----- (000000000040BF7C) ----------------------------------------------------
char *__fastcall sub_40BF7C(char *a1, int a2, const char *a3)
{
  char *v3; // x19
  __int64 v4; // x20
  const char *v5; // x22
  size_t v6; // x21
  char *v7; // x20

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = (signed int)(strlen(a3) + 1);
  v7 = &v3[v4 - v6];
  while ( v3 <= v7 )
  {
    if ( !(unsigned int)memcmp(v3, v5, v6) )
      return v3;
    ++v3;
  }
  return 0LL;
}

//----- (000000000040BFEC) ----------------------------------------------------
__int64 __fastcall sub_40BFEC(unsigned int *a1, void *a2, unsigned int a3)
{
  unsigned int *v3; // x20
  void *v4; // x21
  unsigned int v5; // w22
  unsigned int v6; // w19
  unsigned int v7; // w0

  v3 = a1;
  v4 = a2;
  v5 = a3;
  v6 = sub_40B9E0(a1);
  if ( !v6 )
  {
    v7 = sub_40B9D4(v3 + 1);
    if ( v7 > v5 )
      v6 = -3;
    else
      memmove(v4, v3, v7);
  }
  return v6;
}

//----- (000000000040C050) ----------------------------------------------------
signed __int64 __fastcall sub_40C050(__int64 a1, int a2, const void *a3, int a4, unsigned int a5, const void *a6, int a7)
{
  unsigned int v7; // w19
  int v8; // w20
  __int64 v9; // x0
  const void *v11; // [xsp+28h] [xbp+28h]
  unsigned int v12; // [xsp+3Ch] [xbp+3Ch]

  v7 = a5;
  v8 = a7;
  v11 = a6;
  v9 = sub_40A04C(a1, a2, a3, a4, &v12);
  if ( !v9 )
    return v12;
  if ( v8 + v7 > v12 )
    return 4294967293LL;
  memcpy((void *)(v9 + v7), v11, v8);
  return 0LL;
}

//----- (000000000040C18C) ----------------------------------------------------
__int64 __fastcall sub_40C18C(__int64 a1, unsigned int a2)
{
  __int64 v2; // x19
  __int64 result; // x0
  bool v4; // nf
  char v5; // vf
  int i; // [xsp+2Ch] [xbp+2Ch]

  v2 = a1;
  result = a2;
  for ( i = 0; ; result = sub_40BE24(v2, result, &i) )
  {
    if ( i >= 0 )
    {
      v5 = 0;
      v4 = (signed int)result < 0;
    }
    else
    {
      v5 = 1;
      v4 = 0;
    }
    if ( v4 ^ (unsigned __int8)v5 )
      break;
  }
  return result;
}

// EOF