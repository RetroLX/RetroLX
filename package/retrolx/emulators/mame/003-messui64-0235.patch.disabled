diff -u -r mame-mame0235/3rdparty/lua-zlib/lua_zlib.c messui-tag235/3rdparty/lua-zlib/lua_zlib.c
--- mame-mame0235/3rdparty/lua-zlib/lua_zlib.c	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/3rdparty/lua-zlib/lua_zlib.c	2021-08-27 05:45:31.000000000 +0200
@@ -392,7 +392,7 @@
 
     SETLITERAL("_COPYRIGHT", "Copyright (c) 2009-2010 Brian Maher");
     SETLITERAL("_DESCRIPTION", "Yet another binding to the zlib library");
-    SETLITERAL("_VERSION", "lua-zlib $Id: b619258c75f480717fad20c113c3b1a35f888ce0 $  (tag: mame0235)");
+    SETLITERAL("_VERSION", "lua-zlib $Id: b619258c75f480717fad20c113c3b1a35f888ce0 $  (tag: tag235)");
 
     /* Expose this to lua so we can do a test: */
     SETINT("_TEST_BUFSIZ", LUAL_BUFFERSIZE);
diff -u -r mame-mame0235/android-project/app/src/main/AndroidManifest.xml messui-tag235/android-project/app/src/main/AndroidManifest.xml
--- mame-mame0235/android-project/app/src/main/AndroidManifest.xml	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/android-project/app/src/main/AndroidManifest.xml	2021-08-27 05:45:31.000000000 +0200
@@ -4,8 +4,8 @@
 -->
 <manifest xmlns:android="http://schemas.android.com/apk/res/android"
       package="org.mamedev.mame"
-      android:versionCode="235"
-      android:versionName="0.235"
+      android:versionCode="234"
+      android:versionName="0.234"
       android:installLocation="auto">
 
     <!-- OpenGL ES 2.0 -->
Seulement dans messui-tag235/docs: BSD3Clause.txt
Seulement dans messui-tag235/docs: release
Seulement dans messui-tag235/docs: winui_license.txt
Seulement dans messui-tag235/hash: oric_cass.xml
Seulement dans messui-tag235/hash: vis.xml
Seulement dans messui-tag235/hlsl: 2xBRZ_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: 2xBRZ.vsh
Seulement dans messui-tag235/hlsl: 3xBRZ_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: 3xBRZ.vsh
Seulement dans messui-tag235/hlsl: 4xBRZ_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: 4xBRZ.vsh
Seulement dans messui-tag235/hlsl: 5xBRZ_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: 5xBRZ.vsh
Seulement dans messui-tag235/hlsl: 6xBRZ_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: 6xBRZ.vsh
Seulement dans messui-tag235/hlsl: CRT Geom Bloom_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: CRT Geom Bloom Vertical_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: CRT Geom Bloom Vertical.vsh
Seulement dans messui-tag235/hlsl: CRT Geom Bloom.vsh
Seulement dans messui-tag235/hlsl: CRT-geom-halation-alt_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: CRT-geom-halation-alt.vsh
Seulement dans messui-tag235/hlsl: CRT-geom-halation_overlay_fix_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: CRT-geom-halation_overlay_fix.vsh
Seulement dans messui-tag235/hlsl: CRT-geom-halation_PSone_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: CRT-geom-halation_PSone.vsh
Seulement dans messui-tag235/hlsl: CRT-geom-halation_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: CRT-geom-halation_Vertical_overlay_fix_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: CRT-geom-halation_Vertical_overlay_fix.vsh
Seulement dans messui-tag235/hlsl: CRT-geom-halation_Vertical_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: CRT-geom-halation_Vertical.vsh
Seulement dans messui-tag235/hlsl: CRT-geom-halation.vsh
Seulement dans messui-tag235/hlsl: CRT-geom-halation_x68000_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: CRT-geom-halation_x68000.vsh
Seulement dans messui-tag235/hlsl: CRT Geom HQ_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: CRT Geom HQ Vertical_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: CRT Geom HQ Vertical.vsh
Seulement dans messui-tag235/hlsl: CRT Geom HQ.vsh
Seulement dans messui-tag235/hlsl: CRT-geom_idx16_lut.fsh
Seulement dans messui-tag235/hlsl: CRT Geom LQ_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: CRT Geom LQ Vertical_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: CRT Geom LQ Vertical.vsh
Seulement dans messui-tag235/hlsl: CRT Geom LQ.vsh
Seulement dans messui-tag235/hlsl: CRT Geom MQ_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: CRT Geom MQ Vertical_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: CRT Geom MQ Vertical.vsh
Seulement dans messui-tag235/hlsl: CRT Geom MQ.vsh
Seulement dans messui-tag235/hlsl: CRT-geom_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: CRT-geom_rgb32_lut.fsh
Seulement dans messui-tag235/hlsl: CRT-geom.vsh
Seulement dans messui-tag235/hlsl: Gaussian x_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: Gaussian x.vsh
Seulement dans messui-tag235/hlsl: Gaussian y_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: Gaussian y.vsh
Seulement dans messui-tag235/hlsl: gaussx_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: gaussx.vsh
Seulement dans messui-tag235/hlsl: gaussy_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: gaussy.vsh
Seulement dans messui-tag235/hlsl: Lottes CRT_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: Lottes_CRT_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: Lottes CRT Vertical_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: Lottes CRT Vertical.vsh
Seulement dans messui-tag235/hlsl: Lottes_CRT_VERT_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: Lottes_CRT_VERT.vsh
Seulement dans messui-tag235/hlsl: Lottes CRT.vsh
Seulement dans messui-tag235/hlsl: Lottes_CRT.vsh
Seulement dans messui-tag235/hlsl: NTSC_chain_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: NTSC_chain.vsh
Seulement dans messui-tag235/hlsl: NTSC_rgb32_dir.fsh
Seulement dans messui-tag235/hlsl: NTSC.vsh
diff -u -r mame-mame0235/makefile messui-tag235/makefile
--- mame-mame0235/makefile	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/makefile	2021-08-27 05:45:31.000000000 +0200
@@ -34,7 +34,7 @@
 # NO_USE_PORTAUDIO = 1
 # NO_USE_PULSEAUDIO = 1
 # USE_TAPTUN = 1
-# USE_PCAP = 1
+# USE_PCAP = 0
 # USE_QTDEBUG = 1
 # NO_X11 = 1
 # NO_USE_XINPUT = 1
diff -u -r mame-mame0235/README.md messui-tag235/README.md
--- mame-mame0235/README.md	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/README.md	2021-08-27 05:45:31.000000000 +0200
@@ -1,115 +1,53 @@
 
-# **MAME** #
+# **MESSUI** #
 
-[![Join the chat at https://gitter.im/mamedev/mame](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/mamedev/mame?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
 
-Build status:
-
-| OS/Compiler   | Status        | 
-| ------------- |:-------------:| 
-| Linux/GCC and Clang | ![CI (Linux)](https://github.com/mamedev/mame/workflows/CI%20(Linux)/badge.svg) [![Build Status](https://travis-ci.org/mamedev/mame.svg?branch=master)](https://travis-ci.org/mamedev/mame) |
-| Windows/GCC and MSVC | ![CI (Windows)](https://github.com/mamedev/mame/workflows/CI%20(Windows)/badge.svg) |
-| macOS/Clang | ![CI (macOS)](https://github.com/mamedev/mame/workflows/CI%20(macOS)/badge.svg) |
+What is MESSUI?
+===============
 
-Static analysis status for entire build (except for third-party parts of project):
+MESSUI is an easy-to-use frontend of MESS, for Windows 7 and later.
 
-[![Coverity Scan Status](https://scan.coverity.com/projects/5727/badge.svg?flat=1)](https://scan.coverity.com/projects/mame-emulator)
 
-What is MAME?
-=============
+License
+=======
 
-MAME is a multi-purpose emulation framework.
+* The license of MAME is explained at the MAME repository ( https://github.com/mamedev/mame ).
+* The license of WINUI (the graphical frontend) is BSD3Clause.
 
-MAME's purpose is to preserve decades of software history. As electronic technology continues to rush forward, MAME prevents this important "vintage" software from being lost and forgotten. This is achieved by documenting the hardware and how it functions. The source code to MAME serves as this documentation. The fact that the software is usable serves primarily to validate the accuracy of the documentation (how else can you prove that you have recreated the hardware faithfully?). Over time, MAME (originally stood for Multiple Arcade Machine Emulator) absorbed the sister-project MESS (Multi Emulator Super System), so MAME now documents a wide variety of (mostly vintage) computers, video game consoles and calculators, in addition to the arcade video games that were its initial focus.
 
 How to compile?
-===============
-
-If you're on a *NIX or OSX system, it could be as easy as typing
-
-```
-make
-```
-
-for a MAME build,
-
-```
-make SUBTARGET=arcade
-```
+=============
 
-for an arcade-only build, or
+To create the command-line build:
 
 ```
-make SUBTARGET=mess
+make subtarget=mess OSD=newui
 ```
 
-for MESS build.
-
-See the [Compiling MAME](http://docs.mamedev.org/initialsetup/compilingmame.html) page on our documentation site for more information, including prerequisites for Mac OS X and popular Linux distributions.
-
-For recent versions of OSX you need to install [Xcode](https://developer.apple.com/xcode/) including command-line tools and [SDL 2.0](https://www.libsdl.org/download-2.0.php).
-
-For Windows users, we provide a ready-made [build environment](http://mamedev.org/tools/) based on MinGW-w64.
-
-Visual Studio builds are also possible, but you still need [build environment](http://mamedev.org/tools/) based on MinGW-w64.
-In order to generate solution and project files just run:
+To create the graphical frontend build:
 
 ```
-make vs2019
+make subtarget=mess OSD=messui
 ```
-or use this command to build it directly using msbuild
 
-```
-make vs2019 MSBUILD=1
-```
 
 
 Where can I find out more?
 =============
 
-* [Official MAME Development Team Site](http://mamedev.org/) (includes binary downloads, wiki, forums, and more)
+* [Official MAME Development Team Site](http://mamedev.org/) (includes binary downloads for MAME and MESS, wiki, forums, and more)
 * [Official MESS Wiki](http://mess.redump.net/)
 * [MAME Testers](http://mametesters.org/) (official bug tracker for MAME and MESS)
+* [Official MESSUI site](http://messui.1emulation.com/)
+* [Official MESSUI forum](http://1emulation.com/pc/messui) (bugs, requests, discussion)
 
 
-Contributing
-=============
-
-## Coding standard
-
-MAME source code should be viewed and edited with your editor set to use four spaces per tab. Tabs are used for initial indentation of lines, with one tab used per indentation level. Spaces are used for other alignment within a line.
+Licensing Information
+=====================
 
-Some parts of the code follow [Allman style](https://en.wikipedia.org/wiki/Indent_style#Allman_style); some parts of the code follow [K&R style](https://en.wikipedia.org/wiki/Indent_style#K.26R_style) -- mostly depending on who wrote the original version. **Above all else, be consistent with what you modify, and keep whitespace changes to a minimum when modifying existing source.** For new code, the majority tends to prefer Allman style, so if you don't care much, use that.
+Information about the MAME content can be found at https://github.com/mamedev/mame/blob/master/README.md
 
-All contributors need to either add a standard header for license info (on new files) or inform us of their wishes regarding which of the following licenses they would like their code to be made available under: the [BSD-3-Clause](http://opensource.org/licenses/BSD-3-Clause) license, the [LGPL-2.1](http://opensource.org/licenses/LGPL-2.1), or the [GPL-2.0](http://opensource.org/licenses/GPL-2.0).
+Information about the MAME license can be found at https://github.com/mamedev/mame/blob/master/COPYING
 
-License
-=======
-The MAME project as a whole is made available under the terms of the
-[GNU General Public License, version 2](http://opensource.org/licenses/GPL-2.0)
-or later (GPL-2.0+), since it contains code made available under multiple
-GPL-compatible licenses.  A great majority of the source files (over 90%
-including core files) are made available under the terms of the
-[3-clause BSD License](http://opensource.org/licenses/BSD-3-Clause), and we
-would encourage new contributors to make their contributions available under the
-terms of this license.
-
-Please note that MAME is a registered trademark of Gregory Ember, and permission
-is required to use the "MAME" name, logo, or wordmark.
-
-<a href="http://opensource.org/licenses/GPL-2.0" target="_blank">
-<img align="right" src="http://opensource.org/trademarks/opensource/OSI-Approved-License-100x137.png">
-</a>
-
-    Copyright (C) 1997-2021  MAMEDev and contributors
-
-    This program is free software; you can redistribute it and/or modify it
-    under the terms of the GNU General Public License version 2, as provided in
-    docs/legal/GPL-2.0.
-
-    This program is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
-    more details.
+Information about the WINUI portion can be found at https://github.com/Robbbert/mameui/blob/master/docs/winui_license.txt
 
-Please see COPYING for more details.
diff -u -r mame-mame0235/scripts/src/main.lua messui-tag235/scripts/src/main.lua
--- mame-mame0235/scripts/src/main.lua	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/scripts/src/main.lua	2021-08-27 05:45:31.000000000 +0200
@@ -98,18 +98,30 @@
 		configuration "**/*"
 			flags { "DeploymentContent" }
 
-	configuration { "Release" }
+	configuration { "x64", "Release" }
 		targetsuffix ""
 		if _OPTIONS["PROFILE"] then
 			targetsuffix "p"
 		end
 
-	configuration { "Debug" }
+	configuration { "x64", "Debug" }
 		targetsuffix "d"
 		if _OPTIONS["PROFILE"] then
 			targetsuffix "dp"
 		end
 
+	configuration { "x32", "Release" }
+		targetsuffix "32"
+		if _OPTIONS["PROFILE"] then
+			targetsuffix "32p"
+		end
+
+	configuration { "x32", "Debug" }
+		targetsuffix "32d"
+		if _OPTIONS["PROFILE"] then
+			targetsuffix "32dp"
+		end
+
 	configuration { "mingw*" or "vs20*" }
 		targetextension ".exe"
 
@@ -367,7 +379,7 @@
 	end
 	files {
 		mainfile,
-		GEN_DIR .. "version.cpp",
+		MAME_DIR .. "src/version.cpp",
 		GEN_DIR  .. _target .. "/" .. _subtarget .."/drivlist.cpp",
 	}
 
@@ -410,7 +422,8 @@
 
 	configuration { "mingw*" }
 		custombuildtask {
-			{ GEN_DIR .. "version.cpp" ,  GEN_DIR  .. "resource/" .. rctarget .. "vers.rc",    {  MAME_DIR .. "scripts/build/verinfo.py" }, {"@echo Emitting " .. rctarget .. "vers.rc" .. "...",    PYTHON .. " $(1)  -r -b " .. rctarget .. " $(<) > $(@)" }},
+--			{ GEN_DIR .. "version.cpp" ,  GEN_DIR  .. "resource/" .. rctarget .. "vers.rc",    {  MAME_DIR .. "scripts/build/verinfo.py" }, {"@echo Emitting " .. rctarget .. "vers.rc" .. "...",    PYTHON .. " $(1)  -r -b " .. rctarget .. " $(<) > $(@)" }},
+			{ MAME_DIR .. "src/version.cpp" ,  GEN_DIR  .. "resource/" .. rctarget .. "vers.rc",    {  MAME_DIR .. "scripts/build/verinfo.py" }, {"@echo Emitting " .. rctarget .. "vers.rc" .. "...",    PYTHON .. " $(1)  -r -b " .. rctarget .. " $(<) > $(@)" }},
 		}
 
 	configuration { "vs20*" }
Seulement dans messui-tag235/scripts/src/osd: messui.lua
Seulement dans messui-tag235/scripts/src/osd: newui.lua
Seulement dans messui-tag235/scripts/src/osd: winui_cfg.lua
Seulement dans messui-tag235/scripts/src/osd: winui.lua
diff -u -r mame-mame0235/src/devices/bus/nes/nes_ines.hxx messui-tag235/src/devices/bus/nes/nes_ines.hxx
--- mame-mame0235/src/devices/bus/nes/nes_ines.hxx	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/devices/bus/nes/nes_ines.hxx	2021-08-27 05:45:31.000000000 +0200
@@ -557,7 +557,10 @@
 {
 	const nes_mmc *mmc = nes_mapper_lookup(mapper);
 	if (mmc == nullptr)
-		fatalerror("Unimplemented Mapper %d\n", mapper);
+	{
+		osd_printf_error("Unimplemented Mapper %d\n", mapper);  // MESSUI - do not kill emulator please
+		return;
+	}
 
 	*pcb_id = mmc->pcb_id;
 }
@@ -645,6 +648,11 @@
 		vrom_size += ((header[9] & 0xf0) << 4) * 0x2000;
 	}
 	ines_mapr_setup(mapper, &pcb_id);
+	if (!pcb_id) // MESSUI this paragraph
+	{
+		printf("From nes_cart_slot_device::call_load_ines\n");
+		return;
+	}
 
 	// handle submappers
 	if (submapper)
@@ -1144,6 +1152,11 @@
 	}
 
 	ines_mapr_setup(mapper, &pcb_id);
+	if (!pcb_id) // MESSUI this paragraph
+	{
+		printf("From nes_cart_slot_device::get_default_card_ines\n");
+		return 0;
+	}
 
 	// handle submappers
 	if (submapper)
diff -u -r mame-mame0235/src/devices/bus/nes/nes_slot.cpp messui-tag235/src/devices/bus/nes/nes_slot.cpp
--- mame-mame0235/src/devices/bus/nes/nes_slot.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/devices/bus/nes/nes_slot.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -942,7 +942,10 @@
 		if ((rom[0] == 'U') && (rom[1] == 'N') && (rom[2] == 'I') && (rom[3] == 'F'))
 			slot_string = get_default_card_unif(&rom[0], len);
 
-		return std::string(slot_string);
+		if (slot_string) // MESSUI
+			return std::string(slot_string);
+		else
+			return "";
 	}
 	else
 		return software_get_default_slot("nrom");
diff -u -r mame-mame0235/src/devices/bus/nes/nes_unif.hxx messui-tag235/src/devices/bus/nes/nes_unif.hxx
--- mame-mame0235/src/devices/bus/nes/nes_unif.hxx	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/devices/bus/nes/nes_unif.hxx	2021-08-27 05:45:31.000000000 +0200
@@ -178,7 +178,10 @@
 {
 	const unif *unif_board = nes_unif_lookup(board);
 	if (unif_board == nullptr)
-		fatalerror("Unknown UNIF board %s.\n", board);
+	{
+		osd_printf_error("Unknown UNIF board %s.\n", board);  // MESSUI - don't crash please
+		return;
+	}
 
 	*pcb_id = unif_board->board_idx;
 	*battery = unif_board->nvwram;  // we should implement battery banks based on the size of this...
diff -u -r mame-mame0235/src/devices/bus/snes/snes_slot.cpp messui-tag235/src/devices/bus/snes/snes_slot.cpp
--- mame-mame0235/src/devices/bus/snes/snes_slot.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/devices/bus/snes/snes_slot.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -239,6 +239,8 @@
 	m_cart = dynamic_cast<device_sns_cart_interface *>(get_card_device());
 	if (m_cart != nullptr)
 		m_cart->m_slot = this;
+	else
+		osd_printf_error("The cart could not be loaded\n");   // MESSUI - let us know there's a problem
 
 	m_irq_callback.resolve_safe();
 	m_open_bus_callback.resolve_safe(0xff);
diff -u -r mame-mame0235/src/devices/bus/snes/snes_slot.h messui-tag235/src/devices/bus/snes/snes_slot.h
--- mame-mame0235/src/devices/bus/snes/snes_slot.h	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/devices/bus/snes/snes_slot.h	2021-08-27 05:45:31.000000000 +0200
@@ -257,7 +257,7 @@
 	}
 	sns_cart_slot_device(const machine_config &mconfig, const char *tag, device_t *owner, uint32_t clock);
 	virtual const char *image_interface() const noexcept override { return "snes_cart"; }
-	virtual const char *file_extensions() const noexcept override { return "sfc"; }
+	virtual const char *file_extensions() const noexcept override { return "sfc,smc"; }
 };
 
 // ======================> sns_sufami_cart_slot_device
diff -u -r mame-mame0235/src/devices/cpu/gigatron/gigatron.cpp messui-tag235/src/devices/cpu/gigatron/gigatron.cpp
--- mame-mame0235/src/devices/cpu/gigatron/gigatron.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/devices/cpu/gigatron/gigatron.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -91,7 +91,7 @@
 	m_out = 0;
 
 	m_out_cb(0, 0);
-	m_outx_cb(0, 0);
+	//m_outx_cb(0, 0);    fix crash at start MESSUI
 
 	for(uint16_t i = 0; i < m_ramMask; i++)
 		gigatron_writemem8(i, floor(machine().rand() & 0xff));
diff -u -r mame-mame0235/src/devices/imagedev/floppy.cpp messui-tag235/src/devices/imagedev/floppy.cpp
--- mame-mame0235/src/devices/imagedev/floppy.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/devices/imagedev/floppy.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -208,7 +208,7 @@
 	device_t(mconfig, FLOPPY_CONNECTOR, tag, owner, clock),
 	device_slot_interface(mconfig, *this),
 	formats(nullptr),
-	m_enable_sound(false)
+	m_enable_sound(true)   // MESSUI
 {
 }
 
@@ -268,7 +268,7 @@
 		image_dirty(false),
 		track_dirty(false),
 		ready_counter(0),
-		m_make_sound(false),
+		m_make_sound(true),            // MESSUI
 		m_sound_out(nullptr),
 		m_flux_screen(*this, "flux")
 {
diff -u -r mame-mame0235/src/emu/debug/dvmemory.cpp messui-tag235/src/emu/debug/dvmemory.cpp
--- mame-mame0235/src/emu/debug/dvmemory.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/emu/debug/dvmemory.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -313,7 +313,7 @@
 			for (int i = 0; i < m_bytes_per_chunk; i++)
 			{
 				u8 chval = chunkdata >> (8 * (m_bytes_per_chunk - i - 1));
-				chunkascii += char((ismapped && isprint(chval)) ? chval : '.');
+				chunkascii += char((ismapped && isprint(chval&127)) ? chval&127 : '.');  // MESSUI
 			}
 		}
 	}
@@ -370,7 +370,7 @@
 			for (int i = 0; i < m_bytes_per_chunk; i++)
 			{
 				u8 chval = chunkdata >> (8 * (m_bytes_per_chunk - i - 1));
-				chunkascii += char((ismapped && isprint(chval)) ? chval : '.');
+				chunkascii += char((ismapped && isprint(chval&127)) ? chval&127 : '.');  // MESSUI
 			}
 		}
 	}
diff -u -r mame-mame0235/src/emu/device.h messui-tag235/src/emu/device.h
--- mame-mame0235/src/emu/device.h	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/emu/device.h	2021-08-27 05:45:31.000000000 +0200
@@ -205,7 +205,8 @@
 	template <typename DeviceClass>
 	static std::unique_ptr<device_t> create_device(device_type_impl_base const &type, machine_config const &mconfig, char const *tag, device_t *owner, u32 clock)
 	{
-		return std::make_unique<DeviceClass>(mconfig, tag, owner, clock);
+		//return std::make_unique<DeviceClass>(mconfig, tag, owner, clock);
+		return make_unique_clear<DeviceClass>(mconfig, tag, owner, clock);
 	}
 
 	template <typename DriverClass>
@@ -298,7 +299,8 @@
 	template <typename... Params>
 	std::unique_ptr<DeviceClass> create(machine_config &mconfig, char const *tag, device_t *owner, Params &&... args) const
 	{
-		return std::make_unique<DeviceClass>(mconfig, tag, owner, std::forward<Params>(args)...);
+		//return std::make_unique<DeviceClass>(mconfig, tag, owner, std::forward<Params>(args)...);
+		return make_unique_clear<DeviceClass>(mconfig, tag, owner, std::forward<Params>(args)...);
 	}
 
 	template <typename... Params> DeviceClass &operator()(machine_config &mconfig, char const *tag, Params &&... args) const;
diff -u -r mame-mame0235/src/emu/diimage.cpp messui-tag235/src/emu/diimage.cpp
--- mame-mame0235/src/emu/diimage.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/emu/diimage.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -802,9 +802,9 @@
 					return false;
 
 				if (swinfo->supported() == software_support::PARTIALLY_SUPPORTED)
-					osd_printf_error("WARNING: support for software %s (in list %s) is only partial\n", swname, swlist.list_name());
+					osd_printf_warning("WARNING: support for software %s (in list %s) is only partial\n", swname, swlist.list_name());    // MESSUI
 				else if (swinfo->supported() == software_support::UNSUPPORTED)
-					osd_printf_error("WARNING: support for software %s (in list %s) is only preliminary\n", swname, swlist.list_name());
+					osd_printf_warning("WARNING: support for software %s (in list %s) is only preliminary\n", swname, swlist.list_name());  // MESSUI
 
 				u32 crc = 0;
 				const bool has_crc = util::hash_collection(romp->hashdata()).crc(crc);
diff -u -r mame-mame0235/src/emu/emuopts.cpp messui-tag235/src/emu/emuopts.cpp
--- mame-mame0235/src/emu/emuopts.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/emu/emuopts.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -32,7 +32,7 @@
 	// config options
 	{ nullptr,                                           nullptr,     OPTION_HEADER,     "CORE CONFIGURATION OPTIONS" },
 	{ OPTION_READCONFIG ";rc",                           "1",         OPTION_BOOLEAN,    "enable loading of configuration files" },
-	{ OPTION_WRITECONFIG ";wc",                          "0",         OPTION_BOOLEAN,    "write configuration to (driver).ini on exit" },
+	{ OPTION_WRITECONFIG ";wc",                          "1",         OPTION_BOOLEAN,    "write configuration to (driver).ini on exit" }, // MESSUI
 
 	// search path options
 	{ nullptr,                                           nullptr,     OPTION_HEADER,     "CORE SEARCH PATH OPTIONS" },
@@ -698,18 +698,21 @@
 	}
 
 	// at this point we need to purge stray image options that may no longer be pertinent
+// MESSUI - don't blow up if option not found (occurs with BML3 with 1802 slot)
 	for (auto &opt_name : existing)
 	{
 		auto iter = m_image_options_canonical.find(*opt_name);
-		assert(iter != m_image_options_canonical.end());
+		if (iter != m_image_options_canonical.end())
+		{
 
-		// if this is represented in core_options, remove it
-		if (iter->second.option_entry())
-			remove_entry(*iter->second.option_entry());
+			// if this is represented in core_options, remove it
+			if (iter->second.option_entry())
+				remove_entry(*iter->second.option_entry());
 
-		// remove this option
-		m_image_options_canonical.erase(iter);
-		changed = true;
+			// remove this option
+			m_image_options_canonical.erase(iter);
+			changed = true;
+		}
 	}
 
 	return changed;
@@ -1297,3 +1300,4 @@
 	m_entry = entry;
 	return entry;
 }
+
diff -u -r mame-mame0235/src/emu/image.cpp messui-tag235/src/emu/image.cpp
--- mame-mame0235/src/emu/image.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/emu/image.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -206,7 +206,7 @@
 			|| (!image.exists() && !image.is_reset_and_loading()
 				&& machine().options().has_image_option(image.instance_name()) && !machine().options().image_option(image.instance_name()).value().empty()))
 		{
-			// we have to assemble the image option differently for software lists and for normal images
+			// We've found the image option; check for the two scenarios outlined above
 			std::string image_opt;
 			if (image.exists())
 			{
@@ -218,6 +218,10 @@
 					image_opt = util::string_format("%s:%s", image.software_list_name(), image.full_software_name());
 			}
 
+				// and set the option; note that we have to account for the following two scenarios:
+				//  - The image device was unmounted, in which case the option will no longer exist
+				//	- The image device is still there, but with a different name (e.g. - floppydisk vs floppydisk1), hence
+				//    the need to use the canonical option name (which in the above example, will always be 'floppydisk1')
 			// and set the option (provided that it hasn't been removed out from under us)
 			if (machine().options().exists(image.instance_name()) && machine().options().has_image_option(image.instance_name()))
 				machine().options().image_option(image.instance_name()).specify(std::move(image_opt));
diff -u -r mame-mame0235/src/emu/inpttype.ipp messui-tag235/src/emu/inpttype.ipp
--- mame-mame0235/src/emu/inpttype.ipp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/emu/inpttype.ipp	2021-08-27 05:45:31.000000000 +0200
@@ -806,8 +806,8 @@
 		INPUT_PORT_DIGITAL_TYPE( 0, UI,      UI_ON_SCREEN_DISPLAY,"On Screen Display",      input_seq(KEYCODE_TILDE, input_seq::not_code, KEYCODE_LSHIFT, input_seq::not_code, KEYCODE_RSHIFT) ) \
 		INPUT_PORT_DIGITAL_TYPE( 0, UI,      UI_DEBUG_BREAK,      "Break in Debugger",      input_seq(KEYCODE_TILDE, input_seq::not_code, KEYCODE_LSHIFT, input_seq::not_code, KEYCODE_RSHIFT) ) \
 		INPUT_PORT_DIGITAL_TYPE( 0, UI,      UI_CONFIGURE,        "Config Menu",            input_seq(KEYCODE_TAB) ) \
-		INPUT_PORT_DIGITAL_TYPE( 0, UI,      UI_PAUSE,            "Pause",                  input_seq(KEYCODE_P, input_seq::not_code, KEYCODE_LSHIFT, input_seq::not_code, KEYCODE_RSHIFT) ) \
-		INPUT_PORT_DIGITAL_TYPE( 0, UI,      UI_PAUSE_SINGLE,     "Pause - Single Step",    input_seq(KEYCODE_P, KEYCODE_LSHIFT, input_seq::or_code, KEYCODE_P, KEYCODE_RSHIFT) ) \
+		INPUT_PORT_DIGITAL_TYPE( 0, UI,      UI_PAUSE,            "Pause",                  input_seq(KEYCODE_NUMLOCK, KEYCODE_LCONTROL) ) \
+		INPUT_PORT_DIGITAL_TYPE( 0, UI,      UI_PAUSE_SINGLE,     "Pause - Single Step",    input_seq(KEYCODE_P, KEYCODE_LSHIFT) ) \
 		INPUT_PORT_DIGITAL_TYPE( 0, UI,      UI_REWIND_SINGLE,    "Rewind - Single Step",   input_seq(KEYCODE_TILDE, KEYCODE_LSHIFT) ) \
 		INPUT_PORT_DIGITAL_TYPE( 0, UI,      UI_RESET_MACHINE,    "Reset Machine",          input_seq(KEYCODE_F3, KEYCODE_LSHIFT, input_seq::or_code, KEYCODE_F3, KEYCODE_RSHIFT) ) \
 		INPUT_PORT_DIGITAL_TYPE( 0, UI,      UI_SOFT_RESET,       "Soft Reset",             input_seq(KEYCODE_F3, input_seq::not_code, KEYCODE_LSHIFT, input_seq::not_code, KEYCODE_RSHIFT) ) \
@@ -844,7 +844,7 @@
 		INPUT_PORT_DIGITAL_TYPE( 0, UI,      UI_SHOW_PROFILER,    "Show Profiler",          input_seq(KEYCODE_F11, KEYCODE_LSHIFT) ) \
 		INPUT_PORT_DIGITAL_TYPE( 0, UI,      UI_TOGGLE_UI,        "UI Toggle",              input_seq(KEYCODE_SCRLOCK, input_seq::not_code, KEYCODE_LSHIFT) ) \
 		INPUT_PORT_DIGITAL_TYPE( 0, UI,      UI_RELEASE_POINTER,  "UI Release Pointer",     input_seq(KEYCODE_RCONTROL, KEYCODE_RALT) ) \
-		INPUT_PORT_DIGITAL_TYPE( 0, UI,      UI_PASTE,            "UI Paste Text",          input_seq(KEYCODE_SCRLOCK, KEYCODE_LSHIFT) ) \
+		INPUT_PORT_DIGITAL_TYPE( 0, UI,      UI_PASTE,            "UI Paste Text",          input_seq(KEYCODE_PGUP, KEYCODE_RSHIFT) ) \
 		INPUT_PORT_DIGITAL_TYPE( 0, UI,      UI_TOGGLE_DEBUG,     "Toggle Debugger",        input_seq(KEYCODE_F5) ) \
 		INPUT_PORT_DIGITAL_TYPE( 0, UI,      UI_SAVE_STATE,       "Save State",             input_seq(KEYCODE_F7, KEYCODE_LSHIFT) ) \
 		INPUT_PORT_DIGITAL_TYPE( 0, UI,      UI_LOAD_STATE,       "Load State",             input_seq(KEYCODE_F7, input_seq::not_code, KEYCODE_LSHIFT) ) \
diff -u -r mame-mame0235/src/emu/machine.cpp messui-tag235/src/emu/machine.cpp
--- mame-mame0235/src/emu/machine.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/emu/machine.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -187,23 +187,23 @@
 void running_machine::start()
 {
 	// initialize basic can't-fail systems here
-	m_configuration = std::make_unique<configuration_manager>(*this);
-	m_input = std::make_unique<input_manager>(*this);
-	m_output = std::make_unique<output_manager>(*this);
-	m_render = std::make_unique<render_manager>(*this);
-	m_bookkeeping = std::make_unique<bookkeeping_manager>(*this);
+	m_configuration = make_unique_clear<configuration_manager>(*this);
+	m_input = make_unique_clear<input_manager>(*this);
+	m_output = make_unique_clear<output_manager>(*this);
+	m_render = make_unique_clear<render_manager>(*this);
+	m_bookkeeping = make_unique_clear<bookkeeping_manager>(*this);
 
 	// allocate a soft_reset timer
 	m_soft_reset_timer = m_scheduler.timer_alloc(timer_expired_delegate(FUNC(running_machine::soft_reset), this));
 
 	// initialize UI input
-	m_ui_input = std::make_unique<ui_input_manager>(*this);
+	m_ui_input = make_unique_clear<ui_input_manager>(*this);
 
 	// init the osd layer
 	m_manager.osd().init(*this);
 
 	// create the video manager
-	m_video = std::make_unique<video_manager>(*this);
+	m_video = make_unique_clear<video_manager>(*this);
 	m_ui = manager().create_ui(*this);
 
 	// initialize the base time (needed for doing record/playback)
@@ -217,10 +217,10 @@
 		m_base_time = newbase;
 
 	// initialize natural keyboard support after ports have been initialized
-	m_natkeyboard = std::make_unique<natural_keyboard>(*this);
+	m_natkeyboard = make_unique_clear<natural_keyboard>(*this);
 
 	// initialize the streams engine before the sound devices start
-	m_sound = std::make_unique<sound_manager>(*this);
+	m_sound = make_unique_clear<sound_manager>(*this);
 
 	// resolve objects that can be used by memory maps
 	for (device_t &device : device_enumerator(root_device()))
@@ -231,23 +231,23 @@
 	// needs rom bases), and finally initialize CPUs (which needs
 	// complete address spaces).  These operations must proceed in this
 	// order
-	m_rom_load = std::make_unique<rom_load_manager>(*this);
+	m_rom_load = make_unique_clear<rom_load_manager>(*this);
 	m_memory.initialize();
 
 	// save the random seed or save states might be broken in drivers that use the rand() method
 	save().save_item(NAME(m_rand_seed));
 
 	// initialize image devices
-	m_image = std::make_unique<image_manager>(*this);
-	m_tilemap = std::make_unique<tilemap_manager>(*this);
-	m_crosshair = std::make_unique<crosshair_manager>(*this);
-	m_network = std::make_unique<network_manager>(*this);
+	m_image = make_unique_clear<image_manager>(*this);
+	m_tilemap = make_unique_clear<tilemap_manager>(*this);
+	m_crosshair = make_unique_clear<crosshair_manager>(*this);
+	m_network = make_unique_clear<network_manager>(*this);
 
 	// initialize the debugger
 	if ((debug_flags & DEBUG_FLAG_ENABLED) != 0)
 	{
-		m_debug_view = std::make_unique<debug_view_manager>(*this);
-		m_debugger = std::make_unique<debugger_manager>(*this);
+		m_debug_view = make_unique_clear<debug_view_manager>(*this);
+		m_debugger = make_unique_clear<debugger_manager>(*this);
 	}
 
 	manager().create_custom(*this);
@@ -312,7 +312,7 @@
 		// if we have a logfile, set up the callback
 		if (options().log() && !quiet)
 		{
-			m_logfile = std::make_unique<emu_file>(OPEN_FLAG_WRITE | OPEN_FLAG_CREATE | OPEN_FLAG_CREATE_PATHS);
+			m_logfile = make_unique_clear<emu_file>(OPEN_FLAG_WRITE | OPEN_FLAG_CREATE | OPEN_FLAG_CREATE_PATHS);
 			osd_file::error filerr = m_logfile->open("error.log");
 			if (filerr != osd_file::error::NONE)
 				throw emu_fatalerror("running_machine::run: unable to open error.log file");
@@ -323,7 +323,7 @@
 
 		if (options().debug() && options().debuglog())
 		{
-			m_debuglogfile = std::make_unique<emu_file>(OPEN_FLAG_WRITE | OPEN_FLAG_CREATE | OPEN_FLAG_CREATE_PATHS);
+			m_debuglogfile = make_unique_clear<emu_file>(OPEN_FLAG_WRITE | OPEN_FLAG_CREATE | OPEN_FLAG_CREATE_PATHS);
 			osd_file::error filerr = m_debuglogfile->open("debug.log");
 			if (filerr != osd_file::error::NONE)
 				throw emu_fatalerror("running_machine::run: unable to open debug.log file");
@@ -788,15 +788,15 @@
 		throw emu_fatalerror("Can only call running_machine::add_notifier at init time!");
 
 	if (first)
-		m_notifier_list[event].push_front(std::make_unique<notifier_callback_item>(callback));
+		m_notifier_list[event].push_front(make_unique_clear<notifier_callback_item>(callback));
 
 	// exit notifiers are added to the head, and executed in reverse order
 	else if (event == MACHINE_NOTIFY_EXIT)
-		m_notifier_list[event].push_front(std::make_unique<notifier_callback_item>(callback));
+		m_notifier_list[event].push_front(make_unique_clear<notifier_callback_item>(callback));
 
 	// all other notifiers are added to the tail, and executed in the order registered
 	else
-		m_notifier_list[event].push_back(std::make_unique<notifier_callback_item>(callback));
+		m_notifier_list[event].push_back(make_unique_clear<notifier_callback_item>(callback));
 }
 
 
@@ -810,7 +810,7 @@
 	if (m_current_phase != machine_phase::INIT)
 		throw emu_fatalerror("Can only call running_machine::add_logerror_callback at init time!");
 	m_string_buffer.reserve(1024);
-	m_logerror_list.push_back(std::make_unique<logerror_callback_item>(callback));
+	m_logerror_list.push_back(make_unique_clear<logerror_callback_item>(callback));
 }
 
 
diff -u -r mame-mame0235/src/emu/mconfig.cpp messui-tag235/src/emu/mconfig.cpp
--- mame-mame0235/src/emu/mconfig.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/emu/mconfig.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -99,7 +99,8 @@
 					new_dev->set_input_default(input_device_defaults);
 			}
 			else
-				throw emu_fatalerror("Unknown slot option '%s' in slot '%s'", selval, owner.tag()+1);
+//				throw emu_fatalerror("Unknown slot option '%s' in slot '%s'", selval, owner.tag()+1);   // MESSUI - don't die because of MAME bugs
+				osd_printf_warning("Unknown slot option '%s' in slot '%s'\n", selval, owner.tag()+1);   // MESSUI - just say it
 		}
 	}
 
diff -u -r mame-mame0235/src/emu/romload.cpp messui-tag235/src/emu/romload.cpp
--- mame-mame0235/src/emu/romload.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/emu/romload.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -385,7 +385,7 @@
 		}
 
 		// if we got neither an empty string nor 'default' then warn the user
-		if (!found)
+		if (!found && (specbios[0]!='0'))   // MESSUI (only applies to command-line, i.e. MESS)
 		{
 			m_errorstring.append(util::string_format("%s: invalid BIOS \"%s\", reverting to default\n", device.tag(), specbios));
 			m_warnings++;
diff -u -r mame-mame0235/src/emu/romload.h messui-tag235/src/emu/romload.h
--- mame-mame0235/src/emu/romload.h	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/emu/romload.h	2021-08-27 05:45:31.000000000 +0200
@@ -411,7 +411,7 @@
 	std::string& software_load_warnings_message() { return m_softwarningstring; }
 
 	/* return the number of BAD_DUMP/NO_DUMP warnings we generated */
-	int knownbad() const { return m_knownbad; }
+	int knownbad() const { return 0; } //m_knownbad; }  MESSUI
 
 	/* ----- disk handling ----- */
 
diff -u -r mame-mame0235/src/emu/softlist.cpp messui-tag235/src/emu/softlist.cpp
--- mame-mame0235/src/emu/softlist.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/emu/softlist.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -5,6 +5,7 @@
     softlist.cpp
 
     Software list construction helpers.
+    NOTE: Many changes to keep MESSUI/MAMEUI working. Leave them alone.
 
 ***************************************************************************/
 
@@ -74,7 +75,7 @@
 //  feature, if specified
 //-------------------------------------------------
 
-const char *software_part::feature(std::string_view feature_name) const noexcept
+const char *software_part::feature(const std::string &feature_name) const noexcept
 {
 	// scan the feature list for an entry matching feature_name and return the value
 	auto iter = std::find_if(
@@ -123,7 +124,7 @@
 //  software_info - constructor
 //-------------------------------------------------
 
-software_info::software_info(std::string &&name, std::string &&parent, std::string_view supported) :
+software_info::software_info(std::string &&name, std::string &&parent, const std::string &supported) :
 	m_supported(software_support::SUPPORTED),
 	m_shortname(std::move(name)),
 	m_parentname(std::move(parent))
@@ -141,13 +142,13 @@
 //  optional interface match
 //-------------------------------------------------
 
-const software_part *software_info::find_part(std::string_view part_name, const char *interface) const
+const software_part *software_info::find_part(const std::string &part_name, const char *interface) const
 {
 	// look for the part by name and match against the interface if provided
 	auto iter = std::find_if(
 		m_partdata.begin(),
 		m_partdata.end(),
-		[&part_name, interface] (const software_part &part)
+		[&](const software_part &part)
 		{
 			// try to match the part_name (or all parts if part_name is empty), and then try
 			// to match the interface (or all interfaces if interface is nullptr)
@@ -193,7 +194,7 @@
 	// construction (== execution)
 	softlist_parser(
 			util::core_file &file,
-			std::string_view filename,
+			std::string filename,
 			std::string &listname,
 			std::string &description,
 			std::list<software_info> &infolist,
@@ -261,7 +262,7 @@
 
 softlist_parser::softlist_parser(
 		util::core_file &file,
-		std::string_view filename,
+		std::string filename,
 		std::string &listname,
 		std::string &description,
 		std::list<software_info> &infolist,
@@ -886,7 +887,7 @@
 
 void parse_software_list(
 		util::core_file &file,
-		std::string_view filename,
+		std::string filename,
 		std::string &listname,
 		std::string &description,
 		std::list<software_info> &infolist,
diff -u -r mame-mame0235/src/emu/softlist_dev.cpp messui-tag235/src/emu/softlist_dev.cpp
--- mame-mame0235/src/emu/softlist_dev.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/emu/softlist_dev.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -5,6 +5,7 @@
     softlist_dev.cpp
 
     Software list construction helpers.
+    NOTE: Many changes to keep MESSUI/MAMEUI working. Leave them alone.
 
 ***************************************************************************/
 
@@ -89,6 +90,7 @@
 	m_list_type(softlist_type::ORIGINAL_SYSTEM),
 	m_filter(nullptr),
 	m_parsed(false),
+	m_file(mconfig.options().hash_path(), OPEN_FLAG_READ),
 	m_description("")
 {
 }
@@ -287,15 +289,14 @@
 	m_errors.clear();
 
 	// attempt to open the file
-	emu_file file(mconfig().options().hash_path(), OPEN_FLAG_READ);
-	const osd_file::error filerr = file.open(m_list_name + ".xml");
-	m_filename = file.filename();
+	const osd_file::error filerr = m_file.open(m_list_name + ".xml");
+	m_filename = m_file.filename();
 	if (filerr == osd_file::error::NONE)
 	{
 		// parse if no error
 		std::ostringstream errs;
-		parse_software_list(file, m_filename, m_shortname, m_description, m_infolist, errs);
-		file.close();
+		parse_software_list(m_file, m_filename, m_shortname, m_description, m_infolist, errs);
+		m_file.close();
 		m_errors = errs.str();
 	}
 	else if (filerr == osd_file::error::NOT_FOUND)
diff -u -r mame-mame0235/src/emu/softlist_dev.h messui-tag235/src/emu/softlist_dev.h
--- mame-mame0235/src/emu/softlist_dev.h	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/emu/softlist_dev.h	2021-08-27 05:45:31.000000000 +0200
@@ -151,6 +151,7 @@
 
 	// internal state
 	bool                        m_parsed;
+	emu_file                    m_file;
 	std::string                 m_filename;
 	std::string                 m_shortname;
 	std::string                 m_description;
diff -u -r mame-mame0235/src/emu/softlist.h messui-tag235/src/emu/softlist.h
--- mame-mame0235/src/emu/softlist.h	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/emu/softlist.h	2021-08-27 05:45:31.000000000 +0200
@@ -89,7 +89,7 @@
 
 	// helpers
 	bool matches_interface(const char *interface_list) const noexcept;
-	const char *feature(std::string_view feature_name) const noexcept;
+	const char *feature(const std::string &feature_name) const noexcept;
 
 private:
 	// internal state
@@ -108,7 +108,7 @@
 
 public:
 	// construction/destruction
-	software_info(std::string &&name, std::string &&parent, std::string_view supported);
+	software_info(std::string &&name, std::string &&parent, const std::string &supported);
 	software_info(software_info const &) = delete;
 	software_info(software_info &&) = delete;
 	software_info& operator=(software_info const &) = delete;
@@ -126,7 +126,7 @@
 	const std::list<software_part> &parts() const { return m_partdata; }
 
 	// additional operations
-	const software_part *find_part(std::string_view part_name, const char *interface = nullptr) const;
+	const software_part *find_part(const std::string &part_name, const char *interface = nullptr) const;
 	bool has_multiple_parts(const char *interface) const;
 
 private:
@@ -149,7 +149,7 @@
 // parses a software list
 void parse_software_list(
 		util::core_file &file,
-		std::string_view filename,
+		std::string filename,
 		std::string &listname,
 		std::string &description,
 		std::list<software_info> &infolist,
diff -u -r mame-mame0235/src/emu/video.cpp messui-tag235/src/emu/video.cpp
--- mame-mame0235/src/emu/video.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/emu/video.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -1003,7 +1003,7 @@
 	}
 
 	// if we're past the "time-to-execute" requested, signal an exit
-	if (m_seconds_to_run != 0 && emutime.seconds() >= m_seconds_to_run)
+	if (m_seconds_to_run > 1 && emutime.seconds() >= m_seconds_to_run)
 	{
 		// create a final screenshot
 		emu_file file(machine().options().snapshot_directory(), OPEN_FLAG_WRITE | OPEN_FLAG_CREATE | OPEN_FLAG_CREATE_PATHS);
diff -u -r mame-mame0235/src/emu/video.h messui-tag235/src/emu/video.h
--- mame-mame0235/src/emu/video.h	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/emu/video.h	2021-08-27 05:45:31.000000000 +0200
@@ -53,6 +53,7 @@
 	bool fastforward() const { return m_fastforward; }
 
 	// setters
+	void set_speed_factor(int speed) { m_speed = speed; } // MESSUI
 	void set_frameskip(int frameskip);
 	void set_throttled(bool throttled) { m_throttled = throttled; }
 	void set_throttle_rate(float throttle_rate) { m_throttle_rate = throttle_rate; }
diff -u -r mame-mame0235/src/frontend/mame/audit.cpp messui-tag235/src/frontend/mame/audit.cpp
--- mame-mame0235/src/frontend/mame/audit.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/frontend/mame/audit.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -700,3 +700,81 @@
 	, m_shared_device(nullptr)
 {
 }
+
+
+
+// MESSUI - only report problems that the user can fix
+media_auditor::summary media_auditor::winui_summarize(const char *name, std::string *output)
+{
+	if (m_record_list.empty())
+		return NONE_NEEDED;
+
+	// loop over records
+	summary overall_status = CORRECT;
+	for (audit_record const &record : m_record_list)
+	{
+		summary best_new_status = INCORRECT;
+
+		// skip anything that's fine
+		if ( (record.substatus() == audit_substatus::GOOD)
+			|| (record.substatus() == audit_substatus::GOOD_NEEDS_REDUMP)
+			|| (record.substatus() == audit_substatus::NOT_FOUND_NODUMP)
+			|| (record.substatus() == audit_substatus::FOUND_NODUMP)
+			)
+			continue;
+
+		// output the game name, file name, and length (if applicable)
+		//if (output)
+		{
+			output->append(string_format("%-12s: %s", name, record.name()));
+			if (record.expected_length() > 0)
+				output->append(string_format(" (%d bytes)", record.expected_length()));
+			output->append(" - ");
+		}
+
+		// use the substatus for finer details
+		switch (record.substatus())
+		{
+			case audit_substatus::FOUND_NODUMP:
+				if (output) output->append("NO GOOD DUMP KNOWN\n");
+				best_new_status = BEST_AVAILABLE;
+				break;
+
+			case audit_substatus::FOUND_BAD_CHECKSUM:
+				if (output)
+				{
+					output->append("INCORRECT CHECKSUM:\n");
+					output->append(string_format("EXPECTED: %s\n", record.expected_hashes().macro_string().c_str()));
+					output->append(string_format("   FOUND: %s\n", record.actual_hashes().macro_string().c_str()));
+				}
+				break;
+
+			case audit_substatus::FOUND_WRONG_LENGTH:
+				if (output) output->append(string_format("INCORRECT LENGTH: %d bytes\n", record.actual_length()));
+				break;
+
+			case audit_substatus::NOT_FOUND:
+				if (output)
+				{
+					std::add_pointer_t<device_type> const shared_device = record.shared_device();
+					if (shared_device == NULL)
+						output->append("NOT FOUND\n");
+					else
+						output->append(string_format("NOT FOUND (%s)\n", shared_device->shortname()));
+				}
+				break;
+
+			case audit_substatus::NOT_FOUND_OPTIONAL:
+				if (output) output->append("NOT FOUND BUT OPTIONAL\n");
+				best_new_status = BEST_AVAILABLE;
+				break;
+
+			default:
+				break;
+		}
+
+		// downgrade the overall status if necessary
+		overall_status = (std::max)(overall_status, best_new_status);
+	}
+	return overall_status;
+}
diff -u -r mame-mame0235/src/frontend/mame/audit.h messui-tag235/src/frontend/mame/audit.h
--- mame-mame0235/src/frontend/mame/audit.h	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/frontend/mame/audit.h	2021-08-27 05:45:31.000000000 +0200
@@ -159,6 +159,7 @@
 	summary audit_software(software_list_device &swlist, const software_info &swinfo, const char *validation = AUDIT_VALIDATE_FULL);
 	summary audit_samples();
 	summary summarize(const char *name, std::ostream *output = nullptr) const;
+	summary winui_summarize(const char *name, std::string *output = nullptr); //WINUI - only report problems that the user can fix
 
 private:
 	// internal helpers
diff -u -r mame-mame0235/src/frontend/mame/language.cpp messui-tag235/src/frontend/mame/language.cpp
--- mame-mame0235/src/frontend/mame/language.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/frontend/mame/language.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -69,11 +69,18 @@
 	strreplace(name, " ", "_");
 	strreplace(name, "(", "");
 	strreplace(name, ")", "");
+
+	// MESSUI: See if language file exists. If not, try English, see if that exists. If not, use inbuilt default.
 	emu_file file(m_options.language_path(), OPEN_FLAG_READ);
 	if (file.open(name + PATH_SEPARATOR "strings.mo") != osd_file::error::NONE)
 	{
-		osd_printf_error("Error opening translation file %s\n", name);
-		return;
+		osd_printf_verbose("Error opening translation file %s\n", name);
+		name = "English";
+		if (file.open(name + PATH_SEPARATOR "strings.mo") != osd_file::error::NONE)
+		{
+			osd_printf_verbose("Error opening translation file %s\n", name);
+			return;
+		}
 	}
 
 	u64 const size = file.size();
diff -u -r mame-mame0235/src/frontend/mame/luaengine.cpp messui-tag235/src/frontend/mame/luaengine.cpp
--- mame-mame0235/src/frontend/mame/luaengine.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/frontend/mame/luaengine.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -460,7 +460,7 @@
 		if(!res.valid())
 		{
 			sol::error err = res;
-			osd_printf_error("[LUA ERROR] in call_plugin: %s\n", err.what());
+			osd_printf_warning("[LUA ERROR] in call_plugin: %s\n", err.what());
 		}
 		else
 			return res.get<sol::object>();
@@ -478,7 +478,7 @@
 		if(!res.valid())
 		{
 			sol::error err = res;
-			osd_printf_error("[LUA ERROR] in menu_populate: %s\n", err.what());
+			osd_printf_warning("[LUA ERROR] in menu_populate: %s\n", err.what());
 		}
 		else
 		{
@@ -506,7 +506,7 @@
 		if(!res.valid())
 		{
 			sol::error err = res;
-			osd_printf_error("[LUA ERROR] in menu_callback: %s\n", err.what());
+			osd_printf_warning("[LUA ERROR] in menu_callback: %s\n", err.what());
 		}
 		else
 			ret = res;
@@ -548,7 +548,7 @@
 		if(!ret.valid())
 		{
 			sol::error err = ret;
-			osd_printf_error("[LUA ERROR] in execute_function: %s\n", err.what());
+			osd_printf_warning("[LUA ERROR] in execute_function: %s\n", err.what());
 		}
 		return true;
 	});
@@ -624,7 +624,7 @@
 		if(!ret.valid())
 		{
 			sol::error err = ret;
-			osd_printf_error("[LUA ERROR] in on_missing_mandatory_image: %s\n", err.what());
+			osd_printf_warning("[LUA ERROR] in on_missing_mandatory_image: %s\n", err.what());
 		}
 		else if (ret.get<bool>())
 		{
@@ -1899,7 +1899,7 @@
 	int stat = lua_resume(L, nullptr, 0);
 	if((stat != LUA_OK) && (stat != LUA_YIELD))
 	{
-		osd_printf_error("[LUA ERROR] in resume: %s\n", lua_tostring(L, -1));
+		osd_printf_warning("[LUA ERROR] in resume: %s\n", lua_tostring(L, -1));
 		lua_pop(L, 1);
 	}
 	luaL_unref(m_lua_state, LUA_REGISTRYINDEX, nparam);
@@ -1913,11 +1913,11 @@
 		if(!ret.valid())
 		{
 			sol::error err = ret;
-			osd_printf_error("[LUA ERROR] in run: %s\n", err.what());
+			osd_printf_warning("[LUA ERROR] in run: %s\n", err.what());
 		}
 	}
 	else
-		osd_printf_error("[LUA ERROR] %d loading Lua script\n", (int)res.status());
+		osd_printf_warning("[LUA ERROR] %d loading Lua script\n", (int)res.status());
 }
 
 //-------------------------------------------------
diff -u -r mame-mame0235/src/frontend/mame/mame.cpp messui-tag235/src/frontend/mame/mame.cpp
--- mame-mame0235/src/frontend/mame/mame.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/frontend/mame/mame.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -170,8 +170,9 @@
 		{
 			plugin_options::plugin *p = m_plugins->find(incl);
 			if (!p)
-				fatalerror("Fatal error: Could not load plugin: %s\n", incl);
-			p->m_start = true;
+				osd_printf_warning("Could not load plugin: %s\n", incl); // MESSUI - removed fatalerror
+			else
+				p->m_start = true;
 		}
 
 		// process excludes
@@ -179,8 +180,9 @@
 		{
 			plugin_options::plugin *p = m_plugins->find(excl);
 			if (!p)
-				fatalerror("Fatal error: Unknown plugin: %s\n", excl);
-			p->m_start = false;
+				osd_printf_warning("Unknown plugin: %s\n", excl); // MESSUI - removed fatalerror
+			else
+				p->m_start = false;
 		}
 	}
 
@@ -189,9 +191,9 @@
 	{
 		plugin_options::plugin *p = m_plugins->find(OPTION_CONSOLE);
 		if (!p)
-			fatalerror("Fatal error: Console plugin not found.\n");
-
-		p->m_start = true;
+			osd_printf_warning("Console plugin not found.\n"); // MESSUI - removed fatalerror
+		else
+			p->m_start = true;
 	}
 
 	m_lua->initialize();
diff -u -r mame-mame0235/src/frontend/mame/mameopts.cpp messui-tag235/src/frontend/mame/mameopts.cpp
--- mame-mame0235/src/frontend/mame/mameopts.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/frontend/mame/mameopts.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -31,12 +31,12 @@
 {
 	// parse the INI file defined by the platform (e.g., "mame.ini")
 	// we do this twice so that the first file can change the INI path
-	parse_one_ini(options, emulator_info::get_configname(), OPTION_PRIORITY_MAME_INI);
-	parse_one_ini(options, emulator_info::get_configname(), OPTION_PRIORITY_MAME_INI, &error_stream);
+	parse_parent_ini(options, emulator_info::get_configname(), OPTION_PRIORITY_MAME_INI);
+	parse_parent_ini(options, emulator_info::get_configname(), OPTION_PRIORITY_MAME_INI, &error_stream);
 
 	// debug mode: parse "debug.ini" as well
 	if (options.debug())
-		parse_one_ini(options, "debug", OPTION_PRIORITY_DEBUG_INI, &error_stream);
+		parse_parent_ini(options, "debug", OPTION_PRIORITY_DEBUG_INI, &error_stream);
 
 	// if we have a valid system driver, parse system-specific INI files
 	game_driver const *const cursystem = !driver ? system(options) : driver;
@@ -45,23 +45,23 @@
 
 	// parse "vertical.ini" or "horizont.ini"
 	if (cursystem->flags & ORIENTATION_SWAP_XY)
-		parse_one_ini(options, "vertical", OPTION_PRIORITY_ORIENTATION_INI, &error_stream);
+		parse_parent_ini(options, "vertical", OPTION_PRIORITY_ORIENTATION_INI, &error_stream);
 	else
-		parse_one_ini(options, "horizont", OPTION_PRIORITY_ORIENTATION_INI, &error_stream);
+		parse_parent_ini(options, "horizont", OPTION_PRIORITY_ORIENTATION_INI, &error_stream);
 
 	switch (cursystem->flags & machine_flags::MASK_TYPE)
 	{
 	case machine_flags::TYPE_ARCADE:
-		parse_one_ini(options, "arcade", OPTION_PRIORITY_SYSTYPE_INI, &error_stream);
+		parse_parent_ini(options, "arcade", OPTION_PRIORITY_SYSTYPE_INI, &error_stream);
 		break;
 	case machine_flags::TYPE_CONSOLE:
-		parse_one_ini(options ,"console", OPTION_PRIORITY_SYSTYPE_INI, &error_stream);
+		parse_parent_ini(options ,"console", OPTION_PRIORITY_SYSTYPE_INI, &error_stream);
 		break;
 	case machine_flags::TYPE_COMPUTER:
-		parse_one_ini(options, "computer", OPTION_PRIORITY_SYSTYPE_INI, &error_stream);
+		parse_parent_ini(options, "computer", OPTION_PRIORITY_SYSTYPE_INI, &error_stream);
 		break;
 	case machine_flags::TYPE_OTHER:
-		parse_one_ini(options, "othersys", OPTION_PRIORITY_SYSTYPE_INI, &error_stream);
+		parse_parent_ini(options, "othersys", OPTION_PRIORITY_SYSTYPE_INI, &error_stream);
 		break;
 	default:
 		break;
@@ -73,34 +73,36 @@
 		// parse "raster.ini" for raster games
 		if (device.screen_type() == SCREEN_TYPE_RASTER)
 		{
-			parse_one_ini(options, "raster", OPTION_PRIORITY_SCREEN_INI, &error_stream);
+			parse_parent_ini(options, "raster", OPTION_PRIORITY_SCREEN_INI, &error_stream);
 			break;
 		}
 		// parse "vector.ini" for vector games
 		if (device.screen_type() == SCREEN_TYPE_VECTOR)
 		{
-			parse_one_ini(options, "vector", OPTION_PRIORITY_SCREEN_INI, &error_stream);
+			parse_parent_ini(options, "vector", OPTION_PRIORITY_SCREEN_INI, &error_stream);
 			break;
 		}
 		// parse "lcd.ini" for lcd games
 		if (device.screen_type() == SCREEN_TYPE_LCD)
 		{
-			parse_one_ini(options, "lcd", OPTION_PRIORITY_SCREEN_INI, &error_stream);
+			parse_parent_ini(options, "lcd", OPTION_PRIORITY_SCREEN_INI, &error_stream);
 			break;
 		}
 	}
 
 	// next parse "source/<sourcefile>.ini"
 	std::string sourcename = std::string(core_filename_extract_base(cursystem->type.source(), true)).insert(0, "source" PATH_SEPARATOR);
-	parse_one_ini(options, sourcename.c_str(), OPTION_PRIORITY_SOURCE_INI, &error_stream);
+	parse_parent_ini(options, sourcename.c_str(), OPTION_PRIORITY_SOURCE_INI, &error_stream);
 
 	// then parse the grandparent, parent, and system-specific INIs
 	int parent = driver_list::clone(*cursystem);
 	int gparent = (parent != -1) ? driver_list::clone(parent) : -1;
+	// MESSUI: ignore slots and images unless it is the gamename INI
 	if (gparent != -1)
-		parse_one_ini(options, driver_list::driver(gparent).name, OPTION_PRIORITY_GPARENT_INI, &error_stream);
+		parse_parent_ini(options, driver_list::driver(gparent).name, OPTION_PRIORITY_GPARENT_INI, &error_stream);
 	if (parent != -1)
-		parse_one_ini(options, driver_list::driver(parent).name, OPTION_PRIORITY_PARENT_INI, &error_stream);
+		parse_parent_ini(options,driver_list::driver(parent).name, OPTION_PRIORITY_PARENT_INI, &error_stream);
+
 	parse_one_ini(options, cursystem->name, OPTION_PRIORITY_DRIVER_INI, &error_stream);
 }
 
@@ -208,3 +210,37 @@
 		}
 	}
 }
+
+
+
+// MESSUI
+//------------------------------------------------------------------------------------------
+//  parse_parent_ini - parse the game INI file - we don't want to inherit slots and software
+//------------------------------------------------------------------------------------------
+
+void mame_options::parse_parent_ini(emu_options &options, const char *basename, int priority, std::ostream *error_stream)
+{
+	// don't parse if it has been disabled
+	if (!options.read_config())
+		return;
+
+	// open the file; if we fail, that's ok
+	emu_file file(options.ini_path(), OPEN_FLAG_READ);
+	osd_printf_verbose("Attempting load of %s.ini\n", basename);
+	osd_file::error filerr = file.open(std::string(basename) + ".ini");
+	if (filerr != osd_file::error::NONE)
+		return;
+
+	// parse the file
+	osd_printf_verbose("Parsing_parent %s.ini\n", basename);
+	try
+	{
+		options.parse_parent_file((util::core_file&)file, priority, priority < OPTION_PRIORITY_DRIVER_INI, false);
+	}
+	catch (options_exception &ex)
+	{
+		if (error_stream)
+			util::stream_format(*error_stream, "While parsing %s:\n%s\n", file.fullpath(), ex.message());
+		return;
+	}
+}
diff -u -r mame-mame0235/src/frontend/mame/mameopts.h messui-tag235/src/frontend/mame/mameopts.h
--- mame-mame0235/src/frontend/mame/mameopts.h	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/frontend/mame/mameopts.h	2021-08-27 05:45:31.000000000 +0200
@@ -59,6 +59,7 @@
 private:
 	// INI parsing helper
 	static void parse_one_ini(emu_options &options, const char *basename, int priority, std::ostream *error_stream = nullptr);
+	static void parse_parent_ini(emu_options &options, const char *basename, int priority, std::ostream *error_stream = nullptr); // MESSUI
 };
 
 #endif  // MAME_FRONTEND_MAMEOPTS_H
diff -u -r mame-mame0235/src/frontend/mame/pluginopts.cpp messui-tag235/src/frontend/mame/pluginopts.cpp
--- mame-mame0235/src/frontend/mame/pluginopts.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/frontend/mame/pluginopts.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -74,13 +74,13 @@
 	if (document.HasParseError())
 	{
 		const std::string error(GetParseError_En(document.GetParseError()));
-		osd_printf_error("Unable to parse plugin definition file %s. Errors returned:\n%s", path, error);
+		osd_printf_warning("Unable to parse plugin definition file %s. Errors returned:\n%s", path, error); // MESSUI
 		return false;
 	}
 
 	if (!document["plugin"].IsObject())
 	{
-		osd_printf_error("Bad plugin definition file %s:\n", path);
+		osd_printf_warning("Bad plugin definition file %s:\n", path); // MESSUI
 		return false;
 	}
 
diff -u -r mame-mame0235/src/frontend/mame/ui/info.cpp messui-tag235/src/frontend/mame/ui/info.cpp
--- mame-mame0235/src/frontend/mame/ui/info.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/frontend/mame/ui/info.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -85,7 +85,7 @@
 	for (device_t &device : device_enumerator(config.root_device()))
 	{
 		// the "no sound hardware" warning doesn't make sense when you plug in a sound card
-		if (dynamic_cast<device_sound_interface *>(&device))
+//		if (dynamic_cast<device_sound_interface *>(&device))  // MESSUI
 			m_flags &= ~::machine_flags::NO_SOUND_HW;
 
 		// build overall emulation status
diff -u -r mame-mame0235/src/frontend/mame/ui/inifile.cpp messui-tag235/src/frontend/mame/ui/inifile.cpp
--- mame-mame0235/src/frontend/mame/ui/inifile.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/frontend/mame/ui/inifile.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -59,26 +59,27 @@
 //  load and indexing ini files
 //-------------------------------------------------
 
+// MESSUI - rewritten using native file usage because mame's file.gets doesn't always work
 void inifile_manager::load_ini_category(size_t file, size_t category, std::unordered_set<game_driver const *> &result) const
 {
 	std::string const &filename(m_ini_index[file].first);
-	emu_file fp(m_options.categoryini_path(), OPEN_FLAG_READ);
-	if (fp.open(filename) != osd_file::error::NONE)
+	FILE *fp = fopen(filename.c_str(), "r");
+	if (!fp)
 	{
 		osd_printf_error("Failed to open category file %s for reading\n", filename);
 		return;
 	}
 
 	int64_t const offset(m_ini_index[file].second[category].second);
-	if (fp.seek(offset, SEEK_SET) || (fp.tell() != offset))
+	if (fseek(fp, offset, SEEK_SET))
 	{
-		fp.close();
+		fclose(fp);
 		osd_printf_error("Failed to seek to category offset in file %s\n", filename);
 		return;
 	}
 
 	char rbuf[MAX_CHAR_INFO];
-	while (fp.gets(rbuf, MAX_CHAR_INFO) && rbuf[0] && ('[' != rbuf[0]))
+	while (fgets(rbuf, MAX_CHAR_INFO, fp) && rbuf[0] && ('[' != rbuf[0]))
 	{
 		auto const tail(std::find_if(std::begin(rbuf), std::prev(std::end(rbuf)), [] (char ch) { return !ch || ('\r' == ch) || ('\n' == ch); }));
 		*tail = '\0';
@@ -87,19 +88,24 @@
 			result.emplace(&driver_list::driver(dfind));
 	}
 
-	fp.close();
+	fclose(fp);
 }
 
 //-------------------------------------------------
 //  initialize category
 //-------------------------------------------------
 
+// MESSUI - rewritten using native file usage because mame's file.gets doesn't always work
 void inifile_manager::init_category(std::string &&filename, emu_file &file)
 {
+	FILE *fp;
+	fp = fopen(file.fullpath(), "r");
+	if (!fp)
+		return;
 	categoryindex index;
 	char rbuf[MAX_CHAR_INFO];
 	std::string name;
-	while (file.gets(rbuf, std::size(rbuf)))
+	while (fgets(rbuf, std::size(rbuf), fp))
 	{
 		if ('[' == rbuf[0])
 		{
@@ -107,12 +113,14 @@
 			auto const tail(std::find_if(head, std::end(rbuf), [] (char ch) { return !ch || (']' == ch); }));
 			name.assign(head, tail);
 			if ("FOLDER_SETTINGS" != name)
-				index.emplace_back(std::move(name), file.tell());
+				index.emplace_back(std::move(name), ftell(fp));
 		}
 	}
 	std::stable_sort(index.begin(), index.end(), [] (auto const &x, auto const &y) { return 0 > core_stricmp(x.first.c_str(), y.first.c_str()); });
 	if (!index.empty())
-		m_ini_index.emplace_back(std::move(filename), std::move(index));
+		m_ini_index.emplace_back(file.fullpath(), std::move(index));
+
+	fclose(fp);
 }
 
 
diff -u -r mame-mame0235/src/frontend/mame/ui/ui.cpp messui-tag235/src/frontend/mame/ui/ui.cpp
--- mame-mame0235/src/frontend/mame/ui/ui.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/frontend/mame/ui/ui.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -558,7 +558,7 @@
 						[&warning](const std::reference_wrapper<const std::string> &img)    { warning << "\"" << img.get() << "\""; },
 						[&warning]()                                                        { warning << ","; });
 
-				ui::menu_file_manager::force_file_manager(*this, machine().render().ui_container(), warning.str().c_str());
+				//ui::menu_file_manager::force_file_manager(*this, machine().render().ui_container(), warning.str().c_str());   // MESSUI
 			}
 			break;
 		}
@@ -657,7 +657,8 @@
 		m_popup_text_end = 0;
 
 	// display the internal mouse cursor
-	if (m_mouse_show || (is_menu_active() && machine().options().ui_mouse()))
+	if (machine().options().ui_mouse() && (m_mouse_show || is_menu_active())) //MESSUI - (NEWUI) system pointer always on; MAME pointer always off
+//	if (m_mouse_show || (is_menu_active() && machine().options().ui_mouse()))
 	{
 		int32_t mouse_target_x, mouse_target_y;
 		bool mouse_button;
@@ -1516,7 +1517,7 @@
 	}
 
 	// add CPU overclocking (cheat only)
-	if (machine.options().cheat())
+	//if (machine.options().cheat())
 	{
 		for (device_execute_interface &exec : execute_interface_enumerator(machine.root_device()))
 		{
@@ -1545,7 +1546,7 @@
 		std::string screen_desc = machine_info().get_screen_desc(screen);
 
 		// add refresh rate tweaker
-		if (machine.options().cheat())
+		//if (machine.options().cheat())
 		{
 			std::string str = string_format(_("%1$s Refresh Rate"), screen_desc);
 			slider_alloc(std::move(str), -10000, 0, 10000, 1000, std::bind(&mame_ui_manager::slider_refresh, this, std::ref(screen), _1, _2));
diff -u -r mame-mame0235/src/frontend/mame/ui/ui.h messui-tag235/src/frontend/mame/ui/ui.h
--- mame-mame0235/src/frontend/mame/ui/ui.h	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/frontend/mame/ui/ui.h	2021-08-27 05:45:31.000000000 +0200
@@ -191,6 +191,11 @@
 	void start_save_state();
 	void start_load_state();
 
+	// config callbacks
+	void config_load_s(config_type cfg_type, util::xml::data_node const *parentnode);
+	void config_save_s(config_type cfg_type, util::xml::data_node *parentnode);
+	void config_apply(void);
+
 	// slider controls
 	std::vector<ui::menu_item>&  get_slider_list(void);
 
@@ -290,6 +295,7 @@
 	#endif
 
 	std::vector<std::unique_ptr<slider_state>> m_sliders;
+	std::vector<std::unique_ptr<slider_state>> m_sliders_saved;
 };
 
 
diff -u -r mame-mame0235/src/lib/formats/ccvf_dsk.cpp messui-tag235/src/lib/formats/ccvf_dsk.cpp
--- mame-mame0235/src/lib/formats/ccvf_dsk.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/lib/formats/ccvf_dsk.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -118,7 +118,7 @@
 	} while (start > 0 && end != -1);
 
 	uint64_t pos = 0;
-	int total_size = 200000000/f.cell_size;
+	int total_size = 200000000/f.cell_size;   // never set, division by zero
 
 	for(int track=0; track < f.track_count; track++) {
 		std::vector<uint32_t> buffer;
diff -u -r mame-mame0235/src/lib/util/chdcd.cpp messui-tag235/src/lib/util/chdcd.cpp
--- mame-mame0235/src/lib/util/chdcd.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/lib/util/chdcd.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -886,7 +886,7 @@
 	while (!feof(infile))
 	{
 		/* get the next line */
-		fgets(linebuffer, 511, infile);
+		fgets(linebuffer, 511, infile);printf("%s",linebuffer);
 
 		/* if EOF didn't hit, keep going */
 		if (!feof(infile))
@@ -926,9 +926,8 @@
 				}
 				else
 				{
-					fclose(infile);
-					printf("ERROR: Unhandled track type %s\n", token);
-					return CHDERR_UNSUPPORTED_FORMAT;
+					printf("ERROR: Track %02d: Unhandled track type %s\n", trknum+2,token);   // MESSUI
+					goto nextpart;   // MESSUI
 				}
 			}
 			else if (!strcmp(token, "TRACK"))
@@ -1052,6 +1051,7 @@
 			}
 		}
 	}
+	nextpart: printf("TOTAL TRACKS = %d\n",trknum+1);  // MESSUI
 
 	/* close the input CUE */
 	fclose(infile);
diff -u -r mame-mame0235/src/lib/util/options.cpp messui-tag235/src/lib/util/options.cpp
--- mame-mame0235/src/lib/util/options.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/lib/util/options.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -281,7 +281,8 @@
 	case OPTION_HEADER:
 	default:
 		// anything else is invalid
-		throw options_error_exception("Attempted to set invalid option %s\n", name());
+		//throw options_error_exception("Attempted to set invalid option %s\n", name());    // MESSUI - don't crash for no reason please
+		break;
 	}
 }
 
@@ -1160,3 +1161,81 @@
 		set_priority(OPTION_PRIORITY_DEFAULT);
 	}
 }
+
+// MESSUI
+void core_options::parse_parent_file(util::core_file &inifile, int priority, bool ignore_unknown_options, bool always_override)
+{
+	std::ostringstream error_stream;
+	condition_type condition = condition_type::NONE;
+
+	// loop over lines in the file
+	char buffer[4096];
+	while (inifile.gets(buffer, std::size(buffer)) != nullptr)
+	{
+		// find the extent of the name
+		char *optionname;
+		for (optionname = buffer; *optionname != 0; optionname++)
+			if (!isspace((uint8_t)*optionname))
+				break;
+
+		if (optionname[0] == '#') // this statement is the only extra thing: we don't want slots or images copied to the clone
+		{
+			if (optionname[2] == 'S' && optionname[3] == 'L' && optionname[4] == 'O' && optionname[5] == 'T' )
+				break;
+			if (optionname[2] == 'I' && optionname[3] == 'M' && optionname[4] == 'A' && optionname[5] == 'G' )
+				break;
+		}
+
+		// skip comments
+		if (*optionname == 0 || *optionname == '#')
+			continue;
+
+		// scan forward to find the first space
+		char *temp;
+		for (temp = optionname; *temp != 0; temp++)
+			if (isspace((uint8_t)*temp))
+				break;
+
+		// if we hit the end early, print a warning and continue
+		if (*temp == 0)
+		{
+			condition = std::max(condition, condition_type::WARN);
+			util::stream_format(error_stream, "Warning: invalid line in INI: %s", buffer);
+			continue;
+		}
+
+		// NULL-terminate
+		*temp++ = 0;
+		char *optiondata = temp;
+
+		// scan the data, stopping when we hit a comment
+		bool inquotes = false;
+		for (temp = optiondata; *temp != 0; temp++)
+		{
+			if (*temp == '"')
+				inquotes = !inquotes;
+			if (*temp == '#' && !inquotes)
+				break;
+		}
+		*temp = 0;
+
+		// find our entry
+		entry::shared_ptr curentry = get_entry(optionname);
+		if (!curentry)
+		{
+			if (!ignore_unknown_options)
+			{
+				condition = std::max(condition, condition_type::WARN);
+				util::stream_format(error_stream, "Warning: unknown option in INI: %s\n", optionname);
+			}
+			continue;
+		}
+
+		// set the new data
+		do_set_value(*curentry, trim_spaces_and_quotes(optiondata), priority, error_stream, condition);
+	}
+
+	// did we have any errors that may need to be aggregated?
+	throw_options_exception_if_appropriate(condition, error_stream);
+}
+
diff -u -r mame-mame0235/src/lib/util/options.h messui-tag235/src/lib/util/options.h
--- mame-mame0235/src/lib/util/options.h	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/lib/util/options.h	2021-08-27 05:45:31.000000000 +0200
@@ -190,6 +190,7 @@
 
 	// parsing/input
 	void parse_command_line(const std::vector<std::string> &args, int priority, bool ignore_unknown_options = false);
+	void parse_parent_file(util::core_file &inifile, int priority, bool ignore_unknown_options, bool always_override); // MESSUI
 	void parse_ini_file(util::core_file &inifile, int priority, bool ignore_unknown_options, bool always_override);
 	void copy_from(const core_options &that);
 
diff -u -r mame-mame0235/src/mame/drivers/a2600.cpp messui-tag235/src/mame/drivers/a2600.cpp
--- mame-mame0235/src/mame/drivers/a2600.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/mame/drivers/a2600.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -425,7 +425,7 @@
 	m_tia->vsync_callback().set(FUNC(a2600_state::a2600_tia_vsync_callback));
 
 	SCREEN(config, m_screen, SCREEN_TYPE_RASTER);
-	m_screen->set_raw(MASTER_CLOCK_NTSC, 228, 26, 26 + 160 + 16, 262, 24 , 24 + 192 + 31);
+	m_screen->set_raw(MASTER_CLOCK_NTSC, 228, 26 + 8, 26 + 160 + 8, 268, 36 , 268); // MESSUI
 	m_screen->set_screen_update("tia_video", FUNC(tia_video_device::screen_update));
 
 	/* sound hardware */
@@ -470,7 +470,7 @@
 	m_tia->vsync_callback().set(FUNC(a2600_state::a2600_tia_vsync_callback_pal));
 
 	SCREEN(config, m_screen, SCREEN_TYPE_RASTER);
-	m_screen->set_raw(MASTER_CLOCK_PAL, 228, 26, 26 + 160 + 16, 312, 32, 32 + 228 + 31);
+	m_screen->set_raw(MASTER_CLOCK_PAL, 228, 26 + 8, 26 + 160 + 8, 290, 36, 32 + 228 + 16); // MESSUI
 	m_screen->set_screen_update("tia_video", FUNC(tia_video_device::screen_update));
 
 	/* sound hardware */
diff -u -r mame-mame0235/src/mame/drivers/gamecom.cpp messui-tag235/src/mame/drivers/gamecom.cpp
--- mame-mame0235/src/mame/drivers/gamecom.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/mame/drivers/gamecom.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -296,6 +296,7 @@
 
 	ROM_REGION( 0x40000, "kernel", 0 )
 	ROM_LOAD( "external.bin", 0x00000, 0x40000, CRC(e235a589) SHA1(97f782e72d738f4d7b861363266bf46b438d9b50) )
+	//ROM_FILL(0x5587,1,2)
 ROM_END
 
 //    YEAR  NAME     PARENT  COMPAT  MACHINE  INPUT    CLASS          INIT          COMPANY  FULLNAME    FLAGS
diff -u -r mame-mame0235/src/mame/drivers/snes.cpp messui-tag235/src/mame/drivers/snes.cpp
--- mame-mame0235/src/mame/drivers/snes.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/mame/drivers/snes.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -1183,7 +1183,7 @@
 {
 	snes_state::machine_start();
 
-	if (m_cartslot && m_cartslot->exists())
+	if (m_cartslot && m_cartslot->exists() && m_cartslot->m_cart) // MESSUI - don't crash if bsmempak or strom slot-option is needed
 	{
 		m_maincpu->space(AS_PROGRAM).install_readwrite_handler(0x000000, 0x7dffff, read8m_delegate(*this, FUNC(snes_console_state::snes20_lo_r)), write8m_delegate(*this, FUNC(snes_console_state::snes20_lo_w)));
 		m_maincpu->space(AS_PROGRAM).install_readwrite_handler(0x800000, 0xffffff, read8m_delegate(*this, FUNC(snes_console_state::snes20_hi_r)), write8m_delegate(*this, FUNC(snes_console_state::snes20_hi_w)));
Seulement dans messui-tag235/src/mame: mess.bak
Seulement dans messui-tag235/src/mame: messui.txt
Seulement dans messui-tag235/src/mame: old
diff -u -r mame-mame0235/src/osd/modules/lib/osdobj_common.cpp messui-tag235/src/osd/modules/lib/osdobj_common.cpp
--- mame-mame0235/src/osd/modules/lib/osdobj_common.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/osd/modules/lib/osdobj_common.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -56,7 +56,7 @@
 // OS X can be trusted to have working hardware OpenGL, so default to it on for the best user experience
 	{ OSDOPTION_VIDEO,                        OSDOPTVAL_AUTO,   OPTION_STRING,    "video output method: " },
 	{ OSDOPTION_NUMSCREENS "(1-4)",           "1",              OPTION_INTEGER,   "number of output screens/windows to create; usually, you want just one" },
-	{ OSDOPTION_WINDOW ";w",                  "0",              OPTION_BOOLEAN,   "enable window mode; otherwise, full screen mode is assumed" },
+	{ OSDOPTION_WINDOW ";w",                  "1",              OPTION_BOOLEAN,   "enable window mode; otherwise, full screen mode is assumed" },  // MESSUI
 	{ OSDOPTION_MAXIMIZE ";max",              "1",              OPTION_BOOLEAN,   "default to maximized windows" },
 	{ OSDOPTION_WAITVSYNC ";vs",              "0",              OPTION_BOOLEAN,   "enable waiting for the start of VBLANK before flipping screens (reduces tearing effects)" },
 	{ OSDOPTION_SYNCREFRESH ";srf",           "0",              OPTION_BOOLEAN,   "enable using the start of VBLANK for throttling instead of the game time" },
@@ -94,7 +94,7 @@
 	{ OSDOPTION_SWITCHRES,                    "0",              OPTION_BOOLEAN,   "enable resolution switching" },
 
 	{ nullptr,                                nullptr,          OPTION_HEADER,    "OSD ACCELERATED VIDEO OPTIONS" },
-	{ OSDOPTION_FILTER ";glfilter;flt",       "1",              OPTION_BOOLEAN,   "use bilinear filtering when scaling emulated video" },
+	{ OSDOPTION_FILTER ";glfilter;flt",       "0",              OPTION_BOOLEAN,   "use bilinear filtering when scaling emulated video" },   // MESSUI
 	{ OSDOPTION_PRESCALE "(1-8)",             "1",              OPTION_INTEGER,   "scale emulated video by this factor before applying filters/shaders" },
 
 #if USE_OPENGL
diff -u -r mame-mame0235/src/osd/modules/render/drawd3d.cpp messui-tag235/src/osd/modules/render/drawd3d.cpp
--- mame-mame0235/src/osd/modules/render/drawd3d.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/osd/modules/render/drawd3d.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -1059,39 +1059,40 @@
 	// verify device capabilities
 	if (!(caps.DevCaps & D3DDEVCAPS_CANRENDERAFTERFLIP))
 	{
-		osd_printf_error("Direct3D Error: Your graphics card does not support rendering after a page\n");
-		osd_printf_error("flip.\n");
+		osd_printf_verbose("Direct3D Error: Your graphics card does not support rendering after a page\n");
+		osd_printf_verbose("flip.\n");
 		success = false;
 	}
 
 	if (!(caps.DevCaps & D3DDEVCAPS_HWRASTERIZATION))
 	{
-		osd_printf_error("Direct3D Error: Your graphics card does not support hardware rendering.\n");
+		osd_printf_verbose("Direct3D Error: Your graphics card does not support hardware rendering.\n");
 		success = false;
 	}
 
 	// verify texture operation capabilities
 	if (!(caps.TextureOpCaps & D3DTEXOPCAPS_MODULATE))
 	{
-		osd_printf_error("Direct3D Error: Your graphics card does not support modulate-type blending.\n");
+		osd_printf_verbose("Direct3D Error: Your graphics card does not support modulate-type blending.\n");
 		success = false;
 	}
 
 	if (caps.TextureCaps & D3DPTEXTURECAPS_NONPOW2CONDITIONAL)
 	{
-		osd_printf_error("Direct3D Error: Your graphics card does not fully support non-power-of-two\n");
-		osd_printf_error("textures.\n");
+		osd_printf_verbose("Direct3D Error: Your graphics card does not fully support non-power-of-two\n");
+		osd_printf_verbose("textures.\n");
 		success = false;
 	}
 
 	if (caps.TextureCaps & D3DPTEXTURECAPS_POW2)
 	{
-		osd_printf_error("Direct3D Error: Your graphics card does not support non-power-of-two textures.\n");
+		osd_printf_verbose("Direct3D Error: Your graphics card does not support non-power-of-two textures.\n");
 		success = false;
 	}
+
 	if (caps.TextureCaps & D3DPTEXTURECAPS_SQUAREONLY)
 	{
-		osd_printf_error("Direct3D Error: Your graphics card does not support non-square textures.\n");
+		osd_printf_verbose("Direct3D Error: Your graphics card does not support non-square textures.\n");
 		success = false;
 	}
 
@@ -1099,16 +1100,16 @@
 	result = d3dintf->d3dobj->CheckDeviceFormat(m_adapter, D3DDEVTYPE_HAL, m_pixformat, 0, D3DRTYPE_TEXTURE, D3DFMT_A8R8G8B8);
 	if (FAILED(result))
 	{
-		osd_printf_error("Direct3D Error: Your graphics card does not support the A8R8G8B8 texture format.\n");
+		osd_printf_verbose("Direct3D Error: Your graphics card does not support the A8R8G8B8 texture format.\n");
 		success = false;
 	}
 
 	if (!success)
 	{
-		osd_printf_error("This feature or features are required to use the Direct3D renderer. Please\n");
-		osd_printf_error("select another renderer using the -video option or contact the MAME developers\n");
-		osd_printf_error("with information about your system.\n");
-		return false;
+		osd_printf_verbose("This feature or features are required to use the Direct3D renderer. Please\n");
+		osd_printf_verbose("select another renderer using the -video option or contact the MAME developers\n");
+		osd_printf_verbose("with information about your system.\n");
+		//return false;
 	}
 
 	m_gamma_supported = ((caps.Caps2 & D3DCAPS2_FULLSCREENGAMMA) != 0);
diff -u -r mame-mame0235/src/osd/modules/sound/pa_sound.cpp messui-tag235/src/osd/modules/sound/pa_sound.cpp
--- mame-mame0235/src/osd/modules/sound/pa_sound.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/osd/modules/sound/pa_sound.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -215,6 +215,11 @@
 
 	// 0 = use default
 	stream_params.suggestedLatency = options.pa_latency() ? options.pa_latency() : device_info->defaultLowOutputLatency;
+	// MESSUI
+	if (stream_params.suggestedLatency < 0.001)
+		stream_params.suggestedLatency = 0.001;
+	if (stream_params.suggestedLatency > 0.25)
+		stream_params.suggestedLatency = 0.25;
 
 #ifdef WIN32
 	PaWasapiStreamInfo wasapi_stream_info;
diff -u -r mame-mame0235/src/osd/windows/window.cpp messui-tag235/src/osd/windows/window.cpp
--- mame-mame0235/src/osd/windows/window.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/osd/windows/window.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -720,7 +720,7 @@
 		window->hide_pointer();
 
 		// clip pointer to game video window
-		window->capture_pointer();
+		//window->capture_pointer();      // MESSUI
 	}
 	else
 	{
diff -u -r mame-mame0235/src/osd/windows/winmain.cpp messui-tag235/src/osd/windows/winmain.cpp
--- mame-mame0235/src/osd/windows/winmain.cpp	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/osd/windows/winmain.cpp	2021-08-27 05:45:31.000000000 +0200
@@ -163,7 +163,7 @@
 
 	// video options
 	{ nullptr,                                        nullptr,    OPTION_HEADER,     "WINDOWS VIDEO OPTIONS" },
-	{ WINOPTION_MENU,                                 "0",        OPTION_BOOLEAN,    "enables menu bar if available by UI implementation" },
+	{ WINOPTION_MENU,                                 "1",        OPTION_BOOLEAN,    "enables menu bar if available by UI implementation" },  // MESSUI
 	{ WINOPTION_ATTACH_WINDOW,                        "",         OPTION_STRING,     "attach to arbitrary window" },
 
 	// post-processing options
@@ -283,7 +283,50 @@
 //============================================================
 //  main
 //============================================================
+//MESSUI start
+int main_(int argc, char *argv[])
+{
+	std::vector<std::string> args = osd_get_command_line(argc, argv);
 
+	// use small output buffers on non-TTYs (i.e. pipes)
+	if (!isatty(fileno(stdout)))
+		setvbuf(stdout, (char *) nullptr, _IOFBF, 64);
+	if (!isatty(fileno(stderr)))
+		setvbuf(stderr, (char *) nullptr, _IOFBF, 64);
+
+	// initialize common controls
+	InitCommonControls();
+
+	// set a handler to catch ctrl-c
+	SetConsoleCtrlHandler(control_handler, TRUE);
+
+	// Initialize crash diagnostics
+	diagnostics_module::get_instance()->init_crash_diagnostics();
+
+	// parse config and cmdline options
+	DWORD result;
+	{
+		windows_options options;
+		windows_osd_interface osd(options);
+		// if we're a GUI app, out errors to message boxes
+		// Initialize this after the osd interface so that we are first in the
+		// output order
+		winui_output_error winerror;
+		if (win_is_gui_application() || is_double_click_start(args.size()))
+		{
+			// if we are a GUI app, output errors to message boxes
+			osd_output::push(&winerror);
+			// make sure any console window that opened on our behalf is nuked
+			FreeConsole();
+		}
+		osd.register_options();
+		result = emulator_info::start_frontend(options, osd, args);
+		osd_output::pop(&winerror);
+	}
+
+	return result;
+}
+//MESSUI end
 int main(int argc, char *argv[])
 {
 	std::vector<std::string> args = osd_get_command_line(argc, argv);
diff -u -r mame-mame0235/src/osd/windows/winmain.h messui-tag235/src/osd/windows/winmain.h
--- mame-mame0235/src/osd/windows/winmain.h	2021-08-26 08:44:17.000000000 +0200
+++ messui-tag235/src/osd/windows/winmain.h	2021-08-27 05:45:31.000000000 +0200
@@ -270,6 +270,7 @@
 #if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
 	// Access to exception filter static method
 	friend int main(int argc, char *argv[]);
+	friend int main_(int argc, char *argv[]); //MESSUI
 #endif
 
 public:
Seulement dans messui-tag235/src/osd: winui
Seulement dans messui-tag235/src: version.cpp
